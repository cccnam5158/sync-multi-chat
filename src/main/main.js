const { app, BrowserWindow, BrowserView, ipcMain, session, clipboard, shell } = require('electron');
const path = require('path');
const fs = require('fs');
const os = require('os');
const Store = require('electron-store');
const { initAutoUpdater, checkForUpdates } = require('./updater');

// Session persistence store (SESS-006)
const store = new Store();
const defaultSessionState = {
    serviceUrls: {}, // Current URLs for each service
    layout: '1x4',
    activeServices: ['chatgpt', 'claude', 'gemini', 'perplexity'],
    isAnonymousMode: false,
    isScrollSyncEnabled: false
};

// User data persistence (prompts)
const PROMPT_STORE_KEYS = {
    customPrompts: 'customPrompts',
    predefinedPrompt: 'predefinedPrompt'
};

let robot;
try {
    robot = require('robotjs');
} catch (e) {
    console.warn('robotjs not available:', e.message);
}

const TurndownService = require('turndown');
const { gfm } = require('turndown-plugin-gfm');

// Disable automation features to avoid detection
app.commandLine.appendSwitch('disable-blink-features', 'AutomationControlled');

// Fix for Google CookieMismatch error (Chromium 134+ third-party cookie phase-out)
// Disable third-party cookie deprecation and cookie partitioning (CHIPS) so that
// Google's cross-domain auth flow (accounts.google.com ↔ gemini.google.com) works properly.
app.commandLine.appendSwitch(
    'disable-features',
    'ThirdPartyCookieDeprecationTrial,TrackingProtection3pcd,PartitionedCookies,BoundSessionCredentials'
);

// Windows taskbar grouping/icon behavior is strongly tied to AppUserModelID.
// Setting a stable ID helps Windows associate the running process with the correct icon/shortcut.
if (process.platform === 'win32') {
    app.setAppUserModelId('com.syncmultichat.app');
}
// Note: Removed disable-features=IsolateOrigins,site-per-process and disable-site-isolation-trials
// to allow proper origin isolation for cookie context matching
// app.commandLine.appendSwitch('disable-infobars'); // Not always needed but good practice

// Fix for Google Sign-in "This browser or app may not be secure"
// We need to make sure we don't look like an automation tool.


let mainWindow;
const views = {};
const services = ['chatgpt', 'claude', 'gemini', 'grok', 'perplexity', 'genspark'];
const serviceUrls = {
    chatgpt: 'https://chatgpt.com',
    claude: 'https://claude.ai',
    gemini: 'https://gemini.google.com/app',
    grok: 'https://grok.com',
    perplexity: 'https://www.perplexity.ai',
    genspark: 'https://www.genspark.ai/agents?type=ai_chat'
};

// Domain whitelist for each service (EXTLINK-002)
// URLs within these domains will stay in the webview, others open in external browser
const serviceDomains = {
    chatgpt: ['chatgpt.com', 'chat.openai.com', 'openai.com', 'auth0.com', 'auth.openai.com'],
    claude: ['claude.ai', 'anthropic.com'],
    gemini: ['gemini.google.com', 'google.com', 'accounts.google.com', 'gstatic.com'],
    grok: ['grok.com', 'x.com', 'twitter.com', 'google.com', 'accounts.google.com', 'gstatic.com'],
    perplexity: ['perplexity.ai'],
    genspark: ['genspark.ai', 'google.com', 'accounts.google.com', 'gstatic.com']
};

let currentLayout = '1x4'; // Default layout

let selectorsConfig = {};
let currentZoomLevel = 0.9; // Default zoom level

// Session state tracking (SESS)
let savedSessionUrls = {}; // URLs to load on startup
let isAnonymousMode = false; // Track anonymous mode for session save

// ========================================
// Single AI Mode State (REQ-MODE)
// ========================================
let chatMode = 'multi'; // 'multi' | 'single'
let singleAiService = null; // 'chatgpt' | 'claude' | etc.
const SINGLE_MODE_MAX_INSTANCES = 3; // Reduced to 3 for bot detection mitigation
let singleAiActiveInstances = [true, true, true]; // Up to 3 instances
const singleModeViews = {}; // { 'chatgpt-0': { view, enabled }, 'chatgpt-1': { view, enabled }, ... }
let isClosingWindow = false;

// Track SPA URL changes (e.g. ChatGPT pushState) per view.
const lastKnownMultiUrls = {}; // { chatgpt: 'https://...' }
const lastKnownInstanceUrls = {}; // { 'chatgpt-0': 'https://...' }

// Load selectors
try {
    const configPath = path.join(__dirname, '../config/selectors.json');
    selectorsConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
} catch (err) {
    console.error('Failed to load selectors config:', err);
}

function createWindow() {
    // Icon files are generated by scripts/generate-icons.js into /build (gitignored).
    // In packaged app, icons are in resources folder via extraResources config.
    const { nativeImage } = require('electron');
    
    const getIconPath = (filename) => {
        if (app.isPackaged) {
            return path.join(process.resourcesPath, filename);
        } else {
            return path.join(__dirname, '../../build', filename);
        }
    };
    
    // Try multiple icon sources: 512px PNG (best quality), 256px PNG, ICO
    const png512IconPath = getIconPath('icon-512.png');
    const pngIconPath = getIconPath('icon.png');
    const icoIconPath = getIconPath('icon.ico');
    
    console.log('[Icon] isPackaged:', app.isPackaged);
    console.log('[Icon] PNG-512 path:', png512IconPath, 'exists:', fs.existsSync(png512IconPath));
    console.log('[Icon] PNG path:', pngIconPath, 'exists:', fs.existsSync(pngIconPath));
    console.log('[Icon] ICO path:', icoIconPath, 'exists:', fs.existsSync(icoIconPath));
    
    // Try loading icons in order of preference
    let windowIcon = undefined;
    const iconPaths = [png512IconPath, pngIconPath, icoIconPath];
    
    for (const iconPath of iconPaths) {
        if (fs.existsSync(iconPath)) {
            try {
                const icon = nativeImage.createFromPath(iconPath);
                if (!icon.isEmpty()) {
                    windowIcon = icon;
                    console.log('[Icon] Successfully loaded from:', iconPath, 'size:', icon.getSize());
                    break;
                }
            } catch (err) {
                console.error('[Icon] Failed to load from:', iconPath, err.message);
            }
        }
    }
    
    if (!windowIcon) {
        console.warn('[Icon] No valid icon found, using default Electron icon');
    }

    mainWindow = new BrowserWindow({
        width: 1400,
        height: 900,
        minWidth: 1200,
        minHeight: 700,
        icon: windowIcon,
        webPreferences: {
            preload: path.join(__dirname, 'preload.js'),
            contextIsolation: true,
            nodeIntegration: false
        },
        show: false, // Wait for ready-to-show
        autoHideMenuBar: true // Hide menu bar by default
    });

    // Increase listener limit to prevent MaxListenersExceededWarning 
    // (we have 6 services + several system listeners)
    mainWindow.setMaxListeners(100);

    mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));

    // Create BrowserViews only after main window is ready to avoid startup errors
    mainWindow.once('ready-to-show', () => {
        // Explicitly set icon again after window is ready (Windows fix)
        if (windowIcon) {
            mainWindow.setIcon(windowIcon);
            console.log('[Icon] setIcon() called after ready-to-show');
        }
        mainWindow.show();
        
        // Create views based on chat mode
        if (chatMode === 'single' && singleAiService) {
            console.log(`[Session] Restoring Single AI Mode: ${singleAiService}`);
            // Create Single AI instances (staggered) - limit to SINGLE_MODE_MAX_INSTANCES
            const maxInstances = Math.min(singleAiActiveInstances.length, SINGLE_MODE_MAX_INSTANCES);
            for (let i = 0; i < maxInstances; i++) {
                if (singleAiActiveInstances[i]) {
                    const instanceKey = `${singleAiService}-${i}`;
                    const savedUrl = lastKnownInstanceUrls[instanceKey] || null;
                    const delay = i * SINGLE_VIEW_CREATE_BASE_DELAY_MS + jitterMs(SINGLE_VIEW_CREATE_BASE_DELAY_MS, SINGLE_VIEW_CREATE_JITTER_MS);
                    createSingleModeInstanceView(singleAiService, i, delay, savedUrl);
                }
            }
            // Also create Multi AI views in background (hidden) for mode switching
            services.forEach(service => {
                createServiceView(service);
                // Immediately hide them since we're in Single AI Mode
                if (views[service] && views[service].view) {
                    views[service].enabled = false;
                    try {
                        mainWindow.removeBrowserView(views[service].view);
                    } catch (e) { /* ignore */ }
                }
            });
        } else {
            // Multi AI Mode (default)
            services.forEach(service => {
                createServiceView(service);
            });
        }
    });

    // Save session state when window is closed (catches Alt+F4, X button, etc.)
    // Also give renderer a chance to persist IndexedDB chat history with up-to-date URLs.
    mainWindow.on('close', async (e) => {
        if (isClosingWindow) {
            return;
        }
        isClosingWindow = true;

        // Prevent immediate close; we'll close after renderer confirms (or timeout).
        e.preventDefault();

        try {
            if (mainWindow && !mainWindow.isDestroyed()) {
                mainWindow.webContents.send('app-will-close');
            }
        } catch (err) {
            console.error('[Session] Failed to notify renderer on close:', err);
        }

        // Wait up to 2500ms for renderer to finish saving history
        const waitForRenderer = new Promise((resolve) => {
            ipcMain.once('__app-close-ready__', () => resolve(true));
        });
        await Promise.race([waitForRenderer, new Promise(r => setTimeout(r, 2500))]);

        // Persist electron-store sessionState no matter what
        try { saveSessionState(); } catch (err) { console.error('[Session] saveSessionState failed:', err); }

        // Now actually close
        try {
            if (mainWindow && !mainWindow.isDestroyed()) {
                mainWindow.destroy();
            }
        } finally {
            isClosingWindow = false;
        }
    });

    // Initial Layout is now handled by renderer sending bounds
}

// Centralized handler for request-config to avoid listener accumulation
ipcMain.on('request-config', (event) => {
    // Multi AI Mode: match sender to service view
    for (const [service, viewData] of Object.entries(views)) {
        if (viewData && viewData.view && !viewData.view.webContents.isDestroyed() && event.sender === viewData.view.webContents) {
            if (selectorsConfig[service]) {
                console.log(`[Config] Sending set-config to Multi AI service: ${service}`);
                viewData.view.webContents.send('set-config', { config: selectorsConfig[service], service });
            }
            return;
        }
    }
    // Single AI Mode: match sender to instance view
    for (const [instanceKey, viewData] of Object.entries(singleModeViews)) {
        if (viewData && viewData.view && !viewData.view.webContents.isDestroyed() && event.sender === viewData.view.webContents) {
            const service = viewData.service;
            if (selectorsConfig[service]) {
                console.log(`[Config] Sending set-config to Single AI instance: ${instanceKey} (service: ${service})`);
                viewData.view.webContents.send('set-config', { config: selectorsConfig[service], service, instanceKey });
            }
            return;
        }
    }
    console.log('[Config] request-config received but no matching view found. singleModeViews keys:', Object.keys(singleModeViews), 'views keys:', Object.keys(views));
});

function createServiceView(service) {
    // Cleanup existing view if it exists
    if (views[service] && views[service].view) {
        try {
            if (mainWindow) {
                mainWindow.removeBrowserView(views[service].view);
            }
            // Force destroy webContents to ensure cleanup
            if (!views[service].view.webContents.isDestroyed()) {
                // views[service].view.webContents.destroy(); // Optional, let GC handle it usually
            }
        } catch (e) {
            console.error(`Error cleaning up view for ${service}:`, e);
        }
    }

    const view = new BrowserView({
        webPreferences: {
            preload: path.join(__dirname, '../preload/service-preload.js'),
            partition: `persist:service-${service}`,
            contextIsolation: true,
            nodeIntegration: false,
            webSecurity: true // Explicitly enable web security for proper origin context
        }
    });

    mainWindow.addBrowserView(view);

    // Use saved session URL if available, otherwise use default (SESS-003)
    const urlToLoad = savedSessionUrls[service] || serviceUrls[service];
    const partition = `persist:service-${service}`;
    console.log(`[Session] Loading ${service} with URL: ${urlToLoad}`);
    console.log(`[Session] Partition: ${partition}`);

    // Ensure BrowserView is ready before loading URL to prevent origin context mismatch
    // Use setImmediate to ensure BrowserView is fully attached and ready
    setImmediate(() => {
        // Load URL - this will set the proper origin context
        view.webContents.loadURL(urlToLoad);
    });

    // Modify headers for X-Frame-Options (SEC-001)
    // Skip header manipulation for Google auth domains to preserve cookie integrity (CookieMismatch fix)
    view.webContents.session.webRequest.onHeadersReceived((details, callback) => {
        const url = details.url || '';
        // Google auth domains: do NOT modify response headers (preserves Set-Cookie, CSP, etc.)
        if (url.includes('accounts.google.com') ||
            url.includes('myaccount.google.com') ||
            url.includes('accounts.youtube.com')) {
            callback({ cancel: false, responseHeaders: details.responseHeaders });
            return;
        }
        const responseHeaders = Object.assign({}, details.responseHeaders);
        if (responseHeaders['x-frame-options'] || responseHeaders['X-Frame-Options']) {
            delete responseHeaders['x-frame-options'];
            delete responseHeaders['X-Frame-Options'];
        }
        if (responseHeaders['content-security-policy'] || responseHeaders['Content-Security-Policy']) {
            delete responseHeaders['content-security-policy'];
            delete responseHeaders['Content-Security-Policy'];
        }
        callback({ cancel: false, responseHeaders });
    });

    // Intercept requests to ensure proper origin context for cookie requests
    // This helps prevent origin mismatch errors during initial load
    view.webContents.session.webRequest.onBeforeRequest((details, callback) => {
        // Ensure requests have proper origin context
        // The URL is already set correctly, so we just need to let it proceed
        callback({ cancel: false });
    }, {
        urls: ['<all_urls>']
    });

    // User Agent Spoofing (SEC-002) - Use actual Chromium version to avoid detection
    const userAgent = `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${process.versions.chrome} Safari/537.36`;
    view.webContents.setUserAgent(userAgent);

    // Helper: Check if URL is a conversation URL
    const isConversationUrl = (u) => {
        if (!u || typeof u !== 'string') return false;
        return /\/c\/[a-f0-9-]+/i.test(u) ||       // ChatGPT
               /\/chat\/[a-f0-9-]+/i.test(u) ||    // Claude
               /conversation.*[a-f0-9-]{8,}/i.test(u) ||
               /\/share\/[a-f0-9-]+/i.test(u);
    };

    // Send config when page finishes loading
    view.webContents.on('did-finish-load', () => {

        view.webContents.setZoomFactor(currentZoomLevel);
        view.webContents.send('scroll-sync-state', isScrollSyncEnabled);

        if (selectorsConfig[service]) {
            view.webContents.send('set-config', { config: selectorsConfig[service], service });
        }

        // Defensive URL update: ensure URL bar shows current URL after page loads
        // (with conversation URL protection)
        const currentUrl = view.webContents.getURL();
        const existingUrl = lastKnownMultiUrls[service];
        if (isConversationUrl(currentUrl) || !isConversationUrl(existingUrl)) {
            lastKnownMultiUrls[service] = currentUrl;
        }
        if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send('webview-url-changed', { service, url: currentUrl });
        }
    });

    // URL Bar: Track URL changes (URLBAR-003) with conversation URL protection
    const sendUrlUpdate = () => {
        const currentUrl = view.webContents.getURL();
        const existingUrl = lastKnownMultiUrls[service];
        if (isConversationUrl(currentUrl) || !isConversationUrl(existingUrl)) {
            lastKnownMultiUrls[service] = currentUrl;
        }
        if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send('webview-url-changed', { service, url: currentUrl });
        }
    };

    view.webContents.on('did-navigate', sendUrlUpdate);
    view.webContents.on('did-navigate-in-page', sendUrlUpdate);

    // NOTE: 'request-config' handler is now registered globally to avoid listener accumulation

    // External Link Handling (EXTLINK-001, EXTLINK-003)
    // Check if URL is within allowed domains for this service
    const isAllowedDomain = (url) => {
        try {
            const urlObj = new URL(url);
            const hostname = urlObj.hostname.toLowerCase();
            const allowedDomains = serviceDomains[service] || [];
            return allowedDomains.some(domain =>
                hostname === domain || hostname.endsWith('.' + domain)
            );
        } catch (e) {
            return true; // If URL parsing fails, allow it
        }
    };

    // Intercept navigation to external domains (EXTLINK-003)
    view.webContents.on('will-navigate', (event, url) => {
        if (!isAllowedDomain(url)) {
            console.log(`[${service}] Blocking navigation to external URL: ${url}`);
            event.preventDefault();
            shell.openExternal(url);
        }
    });

    // Handle new window requests (EXTLINK-004)
    view.webContents.setWindowOpenHandler(({ url }) => {
        if (!isAllowedDomain(url)) {
            console.log(`[${service}] Opening external URL in browser: ${url}`);
            shell.openExternal(url);
            return { action: 'deny' };
        }
        // Allow popup for auth flows within allowed domains
        return { action: 'allow' };
    });

    views[service] = { view, enabled: true };
}

// ========================================
// Single AI Mode Functions (REQ-MODE)
// ========================================

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function jitterMs(base, spread) {
    const r = Math.random();
    return Math.max(0, Math.round(base + (r - 0.5) * 2 * spread));
}

// Tunables: Anti-bot detection - conservative delays to mimic human behavior
// Webview creation: 1~1.5 seconds between instances
const SINGLE_VIEW_CREATE_BASE_DELAY_MS = 1000;
const SINGLE_VIEW_CREATE_JITTER_MS = 500;
// Prompt sending: 1.5~4 seconds between instances
const SINGLE_PROMPT_STAGGER_BASE_DELAY_MS = 1500;
const SINGLE_PROMPT_STAGGER_JITTER_MS = 2500;

/**
 * Create a Single AI Mode instance view
 * @param {string} service - The AI service (e.g., 'chatgpt')
 * @param {number} instanceIndex - Instance index (0-3)
 * @param {number} loadDelayMs - Optional delay before loadURL (stagger startup)
 * @param {string} savedUrl - Optional saved URL to load instead of default service URL
 */
function createSingleModeInstanceView(service, instanceIndex, loadDelayMs = 0, savedUrl = null) {
    const instanceKey = `${service}-${instanceIndex}`;
    
    // Cleanup existing view if it exists
    if (singleModeViews[instanceKey] && singleModeViews[instanceKey].view) {
        try {
            if (mainWindow) {
                mainWindow.removeBrowserView(singleModeViews[instanceKey].view);
            }
            // Destroy webContents to free memory
            if (!singleModeViews[instanceKey].view.webContents.isDestroyed()) {
                singleModeViews[instanceKey].view.webContents.close();
            }
        } catch (e) {
            console.error(`Error cleaning up single mode view ${instanceKey}:`, e);
        }
        delete singleModeViews[instanceKey];
    }

    const view = new BrowserView({
        webPreferences: {
            preload: path.join(__dirname, '../preload/service-preload.js'),
            // Use shared partition by default (REQ-MODE-018)
            partition: `persist:service-${service}`,
            contextIsolation: true,
            nodeIntegration: false,
            webSecurity: true
        }
    });

    mainWindow.addBrowserView(view);

    // Use saved URL if available, otherwise fall back to default service URL
    const urlToLoad = savedUrl || serviceUrls[service];
    console.log(`[SingleAI] Creating instance ${instanceKey} with URL: ${urlToLoad}`);

    setTimeout(() => {
        // Check if view still exists and is not destroyed before loading URL
        if (view && view.webContents && !view.webContents.isDestroyed()) {
            view.webContents.loadURL(urlToLoad);
        }
    }, Math.max(0, loadDelayMs));

    // Apply same headers/security as multi-AI mode
    // Skip header manipulation for Google auth domains to preserve cookie integrity (CookieMismatch fix)
    view.webContents.session.webRequest.onHeadersReceived((details, callback) => {
        const url = details.url || '';
        // Google auth domains: do NOT modify response headers (preserves Set-Cookie, CSP, etc.)
        if (url.includes('accounts.google.com') ||
            url.includes('myaccount.google.com') ||
            url.includes('accounts.youtube.com')) {
            callback({ cancel: false, responseHeaders: details.responseHeaders });
            return;
        }
        const responseHeaders = Object.assign({}, details.responseHeaders);
        delete responseHeaders['x-frame-options'];
        delete responseHeaders['X-Frame-Options'];
        delete responseHeaders['content-security-policy'];
        delete responseHeaders['Content-Security-Policy'];
        callback({ cancel: false, responseHeaders });
    });

    // User Agent - Use actual Chromium version to avoid detection
    const userAgent = `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${process.versions.chrome} Safari/537.36`;
    view.webContents.setUserAgent(userAgent);

    // Helper: Check if URL is a conversation URL (reused from service-url-updated handler)
    const isConversationUrl = (u) => {
        if (!u || typeof u !== 'string') return false;
        return /\/c\/[a-f0-9-]+/i.test(u) ||       // ChatGPT
               /\/chat\/[a-f0-9-]+/i.test(u) ||    // Claude
               /conversation.*[a-f0-9-]{8,}/i.test(u) ||
               /\/share\/[a-f0-9-]+/i.test(u);
    };

    // On page load
    view.webContents.on('did-finish-load', () => {
        view.webContents.setZoomFactor(currentZoomLevel);
        view.webContents.send('scroll-sync-state', isScrollSyncEnabled);
        
        if (selectorsConfig[service]) {
            view.webContents.send('set-config', { config: selectorsConfig[service], service, instanceKey });
        }

        // Send URL update (with conversation URL protection)
        const currentUrl = view.webContents.getURL();
        const existingUrl = lastKnownInstanceUrls[instanceKey];
        // Only store if new URL is conversation URL OR existing is not conversation URL
        if (isConversationUrl(currentUrl) || !isConversationUrl(existingUrl)) {
            lastKnownInstanceUrls[instanceKey] = currentUrl;
        }
        if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send('single-instance-url-changed', { 
                instanceKey, 
                service,
                instanceIndex,
                url: currentUrl 
            });
        }
    });

    // URL change tracking (with conversation URL protection)
    const sendUrlUpdate = () => {
        const currentUrl = view.webContents.getURL();
        const existingUrl = lastKnownInstanceUrls[instanceKey];
        // Only store if new URL is conversation URL OR existing is not conversation URL
        if (isConversationUrl(currentUrl) || !isConversationUrl(existingUrl)) {
            lastKnownInstanceUrls[instanceKey] = currentUrl;
        }
        if (mainWindow && !mainWindow.isDestroyed()) {
            mainWindow.webContents.send('single-instance-url-changed', { 
                instanceKey,
                service,
                instanceIndex,
                url: currentUrl 
            });
        }
    };
    view.webContents.on('did-navigate', sendUrlUpdate);
    view.webContents.on('did-navigate-in-page', sendUrlUpdate);

    // External link handling
    const isAllowedDomain = (url) => {
        try {
            const urlObj = new URL(url);
            const hostname = urlObj.hostname.toLowerCase();
            const allowedDomains = serviceDomains[service] || [];
            return allowedDomains.some(domain =>
                hostname === domain || hostname.endsWith('.' + domain)
            );
        } catch (e) {
            return true;
        }
    };

    view.webContents.on('will-navigate', (event, url) => {
        if (!isAllowedDomain(url)) {
            event.preventDefault();
            shell.openExternal(url);
        }
    });

    view.webContents.setWindowOpenHandler(({ url }) => {
        if (!isAllowedDomain(url)) {
            shell.openExternal(url);
            return { action: 'deny' };
        }
        return { action: 'allow' };
    });

    singleModeViews[instanceKey] = { view, enabled: true, service, instanceIndex };
    return view;
}

/**
 * Switch to Single AI Mode
 * @param {string} service - The AI service to use
 * @param {boolean[]} activeInstances - Array of up to SINGLE_MODE_MAX_INSTANCES booleans for instance states
 * @param {Object|null} urls - Optional URLs for each instance (e.g., { 'chatgpt-0': 'https://...' })
 *                             If null/undefined, clears lastKnownInstanceUrls for this service (new session)
 *                             If provided, uses these URLs for session restoration
 */
function switchToSingleAiMode(service, activeInstances = [true, true, true], urls = null) {
    console.log(`[ChatMode] Switching to Single AI Mode: ${service}, urls:`, urls);
    
    // Hide all Multi AI views
    Object.keys(views).forEach(svc => {
        if (views[svc] && views[svc].view) {
            views[svc].view.setBounds({ x: 0, y: 0, width: 0, height: 0 });
            views[svc].enabled = false;
        }
    });

    // Clear existing Single AI views and destroy webContents to free memory
    Object.keys(singleModeViews).forEach(key => {
        if (singleModeViews[key] && singleModeViews[key].view) {
            try {
                mainWindow.removeBrowserView(singleModeViews[key].view);
                // Destroy webContents to free memory
                if (!singleModeViews[key].view.webContents.isDestroyed()) {
                    singleModeViews[key].view.webContents.close();
                }
            } catch (e) {
                console.error(`Error removing single mode view ${key}:`, e);
            }
        }
        delete singleModeViews[key];
    });

    // Clear lastKnownInstanceUrls for this service to prevent stale URLs from being used
    // If urls are provided (session restoration), set them; otherwise clear them (new session)
    for (let i = 0; i < SINGLE_MODE_MAX_INSTANCES; i++) {
        const instanceKey = `${service}-${i}`;
        if (urls && urls[instanceKey]) {
            lastKnownInstanceUrls[instanceKey] = urls[instanceKey];
            console.log(`[ChatMode] Set lastKnownInstanceUrls[${instanceKey}] = ${urls[instanceKey]}`);
        } else {
            delete lastKnownInstanceUrls[instanceKey];
            console.log(`[ChatMode] Cleared lastKnownInstanceUrls[${instanceKey}]`);
        }
    }

    // Update state
    chatMode = 'single';
    singleAiService = service;
    singleAiActiveInstances = activeInstances;

    // Create instances (staggered)
    for (let i = 0; i < SINGLE_MODE_MAX_INSTANCES; i++) {
        if (activeInstances[i]) {
            const instanceKey = `${service}-${i}`;
            // Use URL from urls parameter if available (for session restoration)
            const savedUrl = (urls && urls[instanceKey]) ? urls[instanceKey] : null;
            const delay = i * SINGLE_VIEW_CREATE_BASE_DELAY_MS + jitterMs(SINGLE_VIEW_CREATE_BASE_DELAY_MS, SINGLE_VIEW_CREATE_JITTER_MS);
            createSingleModeInstanceView(service, i, delay, savedUrl);
        }
    }

    // Notify renderer
    if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('chat-mode-changed', {
            mode: 'single',
            service,
            activeInstances
        });
    }
}

/**
 * Switch to Multi AI Mode
 */
function switchToMultiAiMode() {
    console.log(`[ChatMode] Switching to Multi AI Mode`);
    
    // Hide, remove and destroy all Single AI views to free memory
    Object.keys(singleModeViews).forEach(key => {
        if (singleModeViews[key] && singleModeViews[key].view) {
            try {
                mainWindow.removeBrowserView(singleModeViews[key].view);
                // Destroy webContents to free memory
                if (!singleModeViews[key].view.webContents.isDestroyed()) {
                    singleModeViews[key].view.webContents.close();
                }
            } catch (e) {
                console.error(`Error removing single mode view ${key}:`, e);
            }
        }
        delete singleModeViews[key];
    });

    // Update state
    chatMode = 'multi';
    singleAiService = null;
    singleAiActiveInstances = [true, true, true]; // Reset to 3 instances

    // Re-enable Multi AI views and add them back to window
    Object.keys(views).forEach(service => {
        if (views[service]) {
            views[service].enabled = true;
            // Add view back to window
            if (views[service].view && !views[service].view.webContents.isDestroyed()) {
                try {
                    mainWindow.addBrowserView(views[service].view);
                    console.log(`[ChatMode] Re-added view for ${service}`);
                } catch (e) {
                    console.error(`Error adding view ${service}:`, e);
                }
            }
        }
    });

    // Notify renderer
    if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('chat-mode-changed', {
            mode: 'multi',
            service: null,
            activeInstances: null
        });
    }
}

/**
 * Toggle a Single AI Mode instance
 */
function toggleSingleInstance(instanceIndex, enabled) {
    if (chatMode !== 'single' || !singleAiService) return;
    
    const instanceKey = `${singleAiService}-${instanceIndex}`;
    singleAiActiveInstances[instanceIndex] = enabled;

    if (enabled) {
        // Create the instance if it doesn't exist
        if (!singleModeViews[instanceKey]) {
            createSingleModeInstanceView(singleAiService, instanceIndex);
        } else {
            singleModeViews[instanceKey].enabled = true;
        }
    } else {
        // Hide the instance
        if (singleModeViews[instanceKey] && singleModeViews[instanceKey].view) {
            singleModeViews[instanceKey].view.setBounds({ x: 0, y: 0, width: 0, height: 0 });
            singleModeViews[instanceKey].enabled = false;
        }
    }
}

/**
 * Get active views based on current chat mode
 */
function getActiveViews() {
    if (chatMode === 'single') {
        return Object.entries(singleModeViews)
            .filter(([_, v]) => v && v.enabled)
            .map(([key, v]) => ({ key, view: v.view, service: v.service, instanceIndex: v.instanceIndex }));
    } else {
        return Object.entries(views)
            .filter(([_, v]) => v && v.enabled)
            .map(([service, v]) => ({ key: service, view: v.view, service }));
    }
}

// Layout Management
ipcMain.on('update-view-bounds', (event, boundsMap) => {
    if (!mainWindow) return;

    // Apply bounds based on chat mode
    if (chatMode === 'single') {
        // Single AI Mode: Apply bounds to instance views
        Object.entries(boundsMap).forEach(([instanceKey, rect]) => {
            if (singleModeViews[instanceKey] && singleModeViews[instanceKey].view) {
                singleModeViews[instanceKey].view.setBounds({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height
                });
            }
        });
    } else {
        // Multi AI Mode: Apply bounds to service views
        Object.entries(boundsMap).forEach(([service, rect]) => {
            if (views[service] && views[service].view) {
                views[service].view.setBounds({
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height
                });
            }
        });
    }
});

ipcMain.on('set-layout', (event, layout) => {
    currentLayout = layout;
    // We don't calculate layout here anymore, we wait for 'update-view-bounds' from renderer
});

// IPC Handlers
ipcMain.on('send-prompt', async (event, text, activeServices, filePaths = []) => {
    const serviceKeys = Object.keys(activeServices);
    const hasFiles = filePaths && filePaths.length > 0;

    // Process each service independently to prevent one failure from blocking others
    const promises = serviceKeys.map(async (service) => {
        if (activeServices[service] && views[service]) {
            try {
                const selectors = selectorsConfig[service];
                if (selectors) {
                    // Add a small delay for Perplexity if it's being problematic with high load
                    if (service === 'perplexity') {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }

                    if (views[service].view && !views[service].view.webContents.isDestroyed()) {
                        const wc = views[service].view.webContents;

                        // 1. Handle File Uploads if present
                        if (filePaths && filePaths.length > 0 && selectors.fileInputSelector) {
                            try {
                                console.log(`Uploading files to ${service}...`);
                                // Attach debugger
                                try {
                                    wc.debugger.attach('1.3');
                                } catch (err) {
                                    console.log('Debugger already attached');
                                }

                                await wc.debugger.sendCommand('DOM.enable');
                                const { root } = await wc.debugger.sendCommand('DOM.getDocument');

                                // Find file input
                                let nodeId = null;

                                // Special handling for Gemini/Genspark: Use JavaScript to find/access file input
                                // Avoid clicking menu button to prevent file dialog from opening if possible
                                if ((service === 'gemini' || service === 'genspark') && selectors.uploadIconSelector) {
                                    console.log(`[${service}] Searching for file input via JavaScript...`);
                                    try {
                                        // Try to find file input using JavaScript (can find hidden inputs too)
                                        const fileInputFound = await wc.executeJavaScript(`
                                            (function() {
                                                // Search for all file inputs, including hidden ones
                                                const inputs = document.querySelectorAll('input[type="file"]');
                                                if (inputs.length > 0) {
                                                    console.log('[Service JS] Found', inputs.length, 'file input(s)');
                                                    return true;
                                                }
                                                
                                                // Try to find within shadow DOM
                                                const allElements = document.querySelectorAll('*');
                                                for (const el of allElements) {
                                                    if (el.shadowRoot) {
                                                        const shadowInputs = el.shadowRoot.querySelectorAll('input[type="file"]');
                                                        if (shadowInputs.length > 0) {
                                                            console.log('[Service JS] Found', shadowInputs.length, 'file input(s) in shadow DOM');
                                                            return true;
                                                        }
                                                    }
                                                }
                                                
                                                return false;
                                            })()
                                        `);

                                        if (fileInputFound) {
                                            console.log(`[${service}] File input found via JavaScript, proceeding without button clicks`);
                                        } else {
                                            console.log(`[${service}] No file input found, attempting button clicks to create it...`);
                                            // For Genspark: Click icon to open menu (this may create hidden file input)
                                            // For Gemini: Click both icon and menu button
                                            if (selectors.uploadMenuButtonSelector) {
                                                try {
                                                    // Step 1: Click upload icon
                                                    let iconClicked = false;
                                                    for (const iconSel of selectors.uploadIconSelector) {
                                                        try {
                                                            const iconRes = await wc.debugger.sendCommand('DOM.querySelector', { nodeId: root.nodeId, selector: iconSel });
                                                            if (iconRes.nodeId) {
                                                                const box = await wc.debugger.sendCommand('DOM.getBoxModel', { nodeId: iconRes.nodeId });
                                                                if (box.model) {
                                                                    const x = (box.model.content[0] + box.model.content[2]) / 2;
                                                                    const y = (box.model.content[1] + box.model.content[5]) / 2;
                                                                    await wc.debugger.sendCommand('Input.dispatchMouseEvent', { type: 'mousePressed', x, y, button: 'left', clickCount: 1 });
                                                                    await wc.debugger.sendCommand('Input.dispatchMouseEvent', { type: 'mouseReleased', x, y, button: 'left', clickCount: 1 });
                                                                    iconClicked = true;
                                                                    console.log(`[${service}] Upload icon clicked`);
                                                                    await new Promise(resolve => setTimeout(resolve, 500));
                                                                    break;
                                                                }
                                                            }
                                                        } catch (e) { /* ignore */ }
                                                    }

                                                    // Step 2: For Gemini - click menu button. For Genspark - close menu and search for file input
                                                    if (iconClicked && service === 'gemini') {
                                                        for (const menuSel of selectors.uploadMenuButtonSelector) {
                                                            try {
                                                                const newRoot = await wc.debugger.sendCommand('DOM.getDocument');
                                                                const menuRes = await wc.debugger.sendCommand('DOM.querySelector', { nodeId: newRoot.root.nodeId, selector: menuSel });
                                                                if (menuRes.nodeId) {
                                                                    const box = await wc.debugger.sendCommand('DOM.getBoxModel', { nodeId: menuRes.nodeId });
                                                                    if (box.model) {
                                                                        const x = (box.model.content[0] + box.model.content[2]) / 2;
                                                                        const y = (box.model.content[1] + box.model.content[5]) / 2;
                                                                        await wc.debugger.sendCommand('Input.dispatchMouseEvent', { type: 'mousePressed', x, y, button: 'left', clickCount: 1 });
                                                                        await wc.debugger.sendCommand('Input.dispatchMouseEvent', { type: 'mouseReleased', x, y, button: 'left', clickCount: 1 });
                                                                        console.log(`[${service}] Menu button clicked, waiting for file input...`);
                                                                        await new Promise(resolve => setTimeout(resolve, 200));
                                                                        break;
                                                                    }
                                                                }
                                                            } catch (e) { /* ignore */ }
                                                        }
                                                    } else if (iconClicked && service === 'genspark') {
                                                        console.log(`[${service}] Clicking menu item to create file input...`);
                                                        // For Genspark: Click "로컬 파일 찾기" to create file input
                                                        // This will open native dialog. We must set files BEFORE closing dialog
                                                        let menuClicked = false;
                                                        for (const menuSel of selectors.uploadMenuButtonSelector) {
                                                            try {
                                                                const newRoot = await wc.debugger.sendCommand('DOM.getDocument');
                                                                const menuRes = await wc.debugger.sendCommand('DOM.querySelector', { nodeId: newRoot.root.nodeId, selector: menuSel });
                                                                if (menuRes.nodeId) {
                                                                    const box = await wc.debugger.sendCommand('DOM.getBoxModel', { nodeId: menuRes.nodeId });
                                                                    if (box.model) {
                                                                        const x = (box.model.content[0] + box.model.content[2]) / 2;
                                                                        const y = (box.model.content[1] + box.model.content[5]) / 2;
                                                                        await wc.debugger.sendCommand('Input.dispatchMouseEvent', { type: 'mousePressed', x, y, button: 'left', clickCount: 1 });
                                                                        await wc.debugger.sendCommand('Input.dispatchMouseEvent', { type: 'mouseReleased', x, y, button: 'left', clickCount: 1 });
                                                                        menuClicked = true;
                                                                        console.log(`[${service}] Menu item clicked, searching for file input immediately...`);
                                                                        break;
                                                                    }
                                                                }
                                                            } catch (e) { /* ignore */ }
                                                        }

                                                        // Immediately search for file input and set files BEFORE closing dialog
                                                        if (menuClicked) {
                                                            await new Promise(resolve => setTimeout(resolve, 100)); // Brief wait for input creation

                                                            // Search for file input
                                                            let gensparkNodeId = null;
                                                            try {
                                                                const freshRoot = await wc.debugger.sendCommand('DOM.getDocument');
                                                                const inputResult = await wc.debugger.sendCommand('DOM.querySelector', {
                                                                    nodeId: freshRoot.root.nodeId,
                                                                    selector: 'input[type="file"]'
                                                                });
                                                                if (inputResult.nodeId) {
                                                                    gensparkNodeId = inputResult.nodeId;
                                                                    console.log(`[${service}] Found file input immediately after menu click`);
                                                                }
                                                            } catch (e) {
                                                                console.log(`[${service}] Could not find file input:`, e.message);
                                                            }

                                                            // Set files on the input
                                                            if (gensparkNodeId) {
                                                                try {
                                                                    console.log(`[${service}] Setting files via CDP before closing dialog...`);
                                                                    await wc.debugger.sendCommand('DOM.setFileInputFiles', {
                                                                        nodeId: gensparkNodeId,
                                                                        files: filePaths
                                                                    });
                                                                    console.log(`[${service}] Files set successfully!`);
                                                                    nodeId = gensparkNodeId; // Mark as found so we don't search again
                                                                } catch (e) {
                                                                    console.error(`[${service}] Failed to set files:`, e.message);
                                                                }
                                                            }

                                                            // Now close the native dialog with ESC
                                                            if (robot) {
                                                                await new Promise(resolve => setTimeout(resolve, 200));
                                                                robot.keyTap('escape');
                                                                console.log(`[${service}] ESC key sent to close native dialog`);
                                                            }
                                                        }
                                                    }
                                                } catch (e) {
                                                    console.error(`[${service}] Button click fallback failed:`, e);
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        console.error(`[${service}] JavaScript search failed:`, e);
                                    }
                                }

                                // Variable to track if we need to close dialog
                                const shouldSendEsc = (service === 'gemini' || service === 'genspark') && selectors.uploadIconSelector;

                                // Now search for file input (for all services, including Gemini/Genspark after button clicks)
                                for (const selector of selectors.fileInputSelector) {
                                    try {
                                        // Get fresh DOM for Gemini/Genspark
                                        const currentRoot = (service === 'gemini' || service === 'genspark') ?
                                            (await wc.debugger.sendCommand('DOM.getDocument')).root :
                                            root;

                                        const result = await wc.debugger.sendCommand('DOM.querySelector', {
                                            nodeId: currentRoot.nodeId,
                                            selector: selector
                                        });
                                        if (result.nodeId) {
                                            nodeId = result.nodeId;
                                            console.log(`Found file input for ${service} with selector: ${selector}`);
                                            break;
                                        }
                                    } catch (e) { /* ignore */ }
                                }

                                // Fallback 1: Search for all file inputs in the document
                                if (!nodeId) {
                                    try {
                                        // Get fresh DOM for Gemini/Genspark
                                        const currentRoot = (service === 'gemini' || service === 'genspark') ?
                                            (await wc.debugger.sendCommand('DOM.getDocument')).root :
                                            root;

                                        const allInputs = await wc.debugger.sendCommand('DOM.querySelectorAll', {
                                            nodeId: currentRoot.nodeId,
                                            selector: 'input[type="file"]'
                                        });
                                        if (allInputs.nodeIds && allInputs.nodeIds.length > 0) {
                                            // Use the first file input found
                                            nodeId = allInputs.nodeIds[0];
                                            console.log(`Found file input for ${service} using fallback search (found ${allInputs.nodeIds.length} inputs)`);
                                        }
                                    } catch (e) {
                                        console.error(`Fallback file input search failed for ${service}:`, e);
                                    }
                                }

                                // Fallback 2: For Gemini/Genspark specifically, try searching in shadow DOMs
                                if (!nodeId && (service === 'gemini' || service === 'genspark')) {
                                    try {
                                        console.log(`[${service}] Attempting shadow DOM search...`);
                                        const currentRoot = (await wc.debugger.sendCommand('DOM.getDocument')).root;
                                        // Get all elements
                                        const allElements = await wc.debugger.sendCommand('DOM.querySelectorAll', {
                                            nodeId: currentRoot.nodeId,
                                            selector: '*'
                                        });

                                        // Check each element for shadow root
                                        for (const elementNodeId of allElements.nodeIds.slice(0, 100)) { // Limit to first 100 elements
                                            try {
                                                // Request shadow root
                                                await wc.debugger.sendCommand('DOM.requestNode', { objectId: elementNodeId.toString() });
                                                const shadowRoot = await wc.debugger.sendCommand('DOM.describeNode', {
                                                    nodeId: elementNodeId
                                                });

                                                if (shadowRoot.node && shadowRoot.node.shadowRoots && shadowRoot.node.shadowRoots.length > 0) {
                                                    const shadowRootNodeId = shadowRoot.node.shadowRoots[0].nodeId;
                                                    // Try to find file input in this shadow root
                                                    const shadowInputs = await wc.debugger.sendCommand('DOM.querySelectorAll', {
                                                        nodeId: shadowRootNodeId,
                                                        selector: 'input[type="file"]'
                                                    });

                                                    if (shadowInputs.nodeIds && shadowInputs.nodeIds.length > 0) {
                                                        nodeId = shadowInputs.nodeIds[0];
                                                        console.log(`[${service}] Found file input in shadow DOM!`);
                                                        break;
                                                    }
                                                }
                                            } catch (e) { /* ignore */ }
                                        }
                                    } catch (e) {
                                        console.error(`[${service}] Shadow DOM search failed:`, e);
                                    }
                                }

                                // Special delay for Grok to avoid Cloudflare
                                if (service === 'grok' && nodeId) {
                                    console.log(`[Grok] File input found, adding Cloudflare avoidance delay...`);
                                    await new Promise(resolve => setTimeout(resolve, 5000));
                                    console.log(`[Grok] Delay completed, proceeding with file upload`);
                                }

                                if (nodeId) {
                                    // Sanitize arguments for Electron 39 strictness
                                    const sanitizedFiles = filePaths.map(p => String(p));
                                    const sanitizedNodeId = parseInt(nodeId, 10);

                                    console.log(`[CDP] Calling DOM.setFileInputFiles with nodeId: ${sanitizedNodeId}, files:`, sanitizedFiles);

                                    await wc.debugger.sendCommand('DOM.setFileInputFiles', {
                                        files: sanitizedFiles,
                                        nodeId: sanitizedNodeId
                                    });
                                    console.log(`Files uploaded to ${service}`);

                                    // Verify file upload by checking for UI indicators
                                    if (selectors.uploadedFileSelector) {
                                        console.log(`[${service}] Verifying upload via UI indicators...`);
                                        let uploadConfirmed = false;
                                        const startTime = Date.now();
                                        const timeout = 5000; // 5 seconds timeout

                                        while (Date.now() - startTime < timeout) {
                                            try {
                                                // Check if any of the uploaded file selectors exist
                                                const checkScript = `
                                            (function() {
                                                const selectors = ${JSON.stringify(selectors.uploadedFileSelector)};
                                                for (const sel of selectors) {
                                                    if (document.querySelector(sel)) return true;
                                                }
                                                return false;
                                            })()
                                        `;
                                                const found = await wc.executeJavaScript(checkScript);
                                                if (found) {
                                                    uploadConfirmed = true;
                                                    console.log(`[${service}] File upload confirmed via UI indicator`);
                                                    break;
                                                }
                                            } catch (e) { /* ignore */ }
                                            await new Promise(resolve => setTimeout(resolve, 500));
                                        }

                                        if (!uploadConfirmed) {
                                            console.warn(`[${service}] Upload UI indicator not found within timeout, proceeding anyway...`);
                                        }
                                    }

                                    // Wait longer for upload to process
                                    const uploadDelay = service === 'grok' ? 4000 : 2000; // Extra time for Grok
                                    await new Promise(resolve => setTimeout(resolve, uploadDelay));

                                    // Wait for send button to be enabled (check up to 5 times)
                                    for (let i = 0; i < 5; i++) {
                                        try {
                                            let sendBtnEnabled = false;
                                            for (const btnSelector of selectors.sendButtonSelector) {
                                                const btnResult = await wc.debugger.sendCommand('DOM.querySelector', {
                                                    nodeId: root.nodeId,
                                                    selector: btnSelector
                                                });
                                                if (btnResult.nodeId) {
                                                    const attrs = await wc.debugger.sendCommand('DOM.getAttributes', {
                                                        nodeId: btnResult.nodeId
                                                    });
                                                    // Check if button is not disabled
                                                    if (!attrs.attributes.includes('disabled')) {
                                                        sendBtnEnabled = true;
                                                        console.log(`Send button enabled for ${service}`);
                                                        break;
                                                    }
                                                }
                                            }
                                            if (sendBtnEnabled) break;
                                        } catch (e) { /* ignore */ }
                                        await new Promise(resolve => setTimeout(resolve, 500));
                                    }
                                } else {
                                    console.warn(`File input not found for ${service}`);
                                }

                                // ALWAYS try to close dialog for Gemini/Genspark if we likely opened it
                                if (shouldSendEsc && robot) {
                                    console.log(`[${service}] Sending ESC key cleanup (regardless of upload success)...`);
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    try {
                                        robot.keyTap('escape');
                                        console.log(`[${service}] ESC key sent`);
                                    } catch (e) {
                                        console.error(`[${service}] Failed to send ESC key:`, e);
                                    }
                                }

                                wc.debugger.detach();
                            } catch (uploadErr) {
                                console.error(`Error uploading files to ${service}:`, uploadErr);
                                try { wc.debugger.detach(); } catch (e) { }
                            }
                        }

                        // 2. Inject Prompt
                        wc.send('inject-prompt', { text, selectors, autoSend: !hasFiles });
                        console.log(`Sent prompt to ${service}`);
                    }
                }
            } catch (error) {
                console.error(`Failed to send prompt to ${service}:`, error);
            }
        }
    });

    await Promise.all(promises);

    if (hasFiles) {
        event.sender.send('file-upload-complete');
    }
});

ipcMain.on('confirm-send', (event) => {
    console.log('Received confirm-send event');
    if (chatMode === 'single' && singleAiService) {
        const selectors = selectorsConfig[singleAiService];
        if (!selectors) return;
        getEnabledSingleInstances().forEach(({ instanceKey, wc }) => {
            try {
                wc.send('click-send-button', { selectors });
                console.log(`Sent click-send-button to ${instanceKey}`);
            } catch (e) {
                console.error(`Failed click-send-button to ${instanceKey}:`, e);
            }
        });
        return;
    }

    // Multi AI Mode: Iterate over all active views and trigger send button click
    Object.keys(views).forEach(service => {
        if (views[service] && views[service].view && !views[service].view.webContents.isDestroyed()) {
            const selectors = selectorsConfig[service];
            if (selectors) {
                views[service].view.webContents.send('click-send-button', { selectors });
                console.log(`Sent click-send-button to ${service}`);
            }
        }
    });
});

ipcMain.handle('save-temp-file', async (event, { buffer, name }) => {
    try {
        const tempDir = os.tmpdir();
        const filePath = path.join(tempDir, name);
        await fs.promises.writeFile(filePath, Buffer.from(buffer));
        return filePath;
    } catch (error) {
        console.error('Error saving temp file:', error);
        throw error;
    }
});

ipcMain.on('toggle-service', (event, service, isEnabled) => {
    if (isEnabled) {
        const viewObj = views[service];
        // Check if view is valid
        let isValid = viewObj && viewObj.view;
        if (isValid) {
            try {
                if (viewObj.view.webContents.isDestroyed() || viewObj.view.webContents.isCrashed()) {
                    isValid = false;
                }
            } catch (e) {
                isValid = false;
            }
        }

        if (!isValid) {
            console.log(`Recreating view for ${service} (Toggle ON)`);
            createServiceView(service);
            // createServiceView adds it and sets enabled=true
        } else {
            // Just enable existing
            if (!viewObj.enabled) {
                viewObj.enabled = true;
                mainWindow.addBrowserView(viewObj.view);
            }
        }
    } else {
        // Disable
        if (views[service]) {
            views[service].enabled = false;
            if (views[service].view) {
                try {
                    mainWindow.removeBrowserView(views[service].view);
                } catch (e) { /* ignore */ }
            }
        }
    }
    // Layout update will be triggered by renderer via toggle change -> updateLayoutState -> renderLayout -> updateBounds
});

// Request current URLs for all services (URLBAR - for layout/toggle changes)
ipcMain.on('request-current-urls', async () => {
    if (!mainWindow || mainWindow.isDestroyed()) return;

    // Helper: Check if URL is a conversation URL
    const isConversationUrl = (url) => {
        if (!url || typeof url !== 'string') return false;
        return /\/c\/[a-f0-9-]+/i.test(url) ||       // ChatGPT
               /\/chat\/[a-f0-9-]+/i.test(url) ||    // Claude
               /conversation.*[a-f0-9-]{8,}/i.test(url) ||
               /\/share\/[a-f0-9-]+/i.test(url) ||
               /app\/[a-f0-9]+/i.test(url);          // Gemini
    };

    if (chatMode === 'single') {
        for (const { instanceKey, service, instanceIndex, wc } of getEnabledSingleInstances()) {
            try {
                // Try executeJavaScript for SPA accuracy
                const actualUrl = await wc.executeJavaScript('window.location.href', true);
                const wcUrl = wc.getURL();
                const cachedUrl = lastKnownInstanceUrls[instanceKey];
                
                // Pick best URL: prefer conversation URLs
                let bestUrl = wcUrl;
                if (isConversationUrl(actualUrl)) {
                    bestUrl = actualUrl;
                } else if (isConversationUrl(cachedUrl)) {
                    bestUrl = cachedUrl;
                } else if (actualUrl) {
                    bestUrl = actualUrl;
                }
                
                console.log(`[URL Request] ${instanceKey}: actualUrl=${actualUrl}, cached=${cachedUrl}, picked=${bestUrl}`);
                
                if (bestUrl) {
                    mainWindow.webContents.send('single-instance-url-changed', {
                        instanceKey,
                        service,
                        instanceIndex,
                        url: bestUrl
                    });
                }
            } catch (e) {
                // Fallback
                const url = lastKnownInstanceUrls[instanceKey] || wc.getURL();
                if (url) {
                    mainWindow.webContents.send('single-instance-url-changed', {
                        instanceKey,
                        service,
                        instanceIndex,
                        url
                    });
                }
            }
        }
        return;
    }

    // Multi AI Mode
    for (const service of services) {
        if (views[service] && views[service].view && !views[service].view.webContents.isDestroyed()) {
            try {
                const wc = views[service].view.webContents;
                const actualUrl = await wc.executeJavaScript('window.location.href', true);
                const wcUrl = wc.getURL();
                const cachedUrl = lastKnownMultiUrls[service];
                
                let bestUrl = wcUrl;
                if (isConversationUrl(actualUrl)) {
                    bestUrl = actualUrl;
                } else if (isConversationUrl(cachedUrl)) {
                    bestUrl = cachedUrl;
                } else if (actualUrl) {
                    bestUrl = actualUrl;
                }
                
                if (bestUrl) {
                    mainWindow.webContents.send('webview-url-changed', { service, url: bestUrl });
                }
            } catch (e) {
                const url = lastKnownMultiUrls[service] || views[service].view.webContents.getURL();
                if (url) {
                    mainWindow.webContents.send('webview-url-changed', { service, url });
                }
            }
        }
    }
});

// Helper: canonical "reset/new chat" URL for each service
function getServiceResetUrl(service) {
    let url = serviceUrls[service];
    if (service === 'claude') {
        url = 'https://claude.ai/new';
    }
    // ChatGPT and Gemini use base URL which usually redirects to new chat
    // For ChatGPT, https://chatgpt.com/ is correct.
    // For Gemini, https://gemini.google.com/app is correct.
    return url;
}

ipcMain.on('new-chat', () => {
    if (chatMode === 'single' && singleAiService) {
        const url = getServiceResetUrl(singleAiService);
        console.log(`[SingleAI] Resetting chat for all instances of ${singleAiService} to ${url}`);

        // Clear cached URLs for all instances - this is crucial for new chat
        for (let i = 0; i < SINGLE_MODE_MAX_INSTANCES; i++) {
            const instanceKey = `${singleAiService}-${i}`;
            delete lastKnownInstanceUrls[instanceKey];
            console.log(`[SingleAI] Cleared lastKnownInstanceUrls[${instanceKey}] for new chat`);
        }

        getEnabledSingleInstances().forEach(({ instanceKey, wc }) => {
            try {
                console.log(`[SingleAI] Resetting chat for ${instanceKey} to ${url}`);
                wc.loadURL(url);
            } catch (e) {
                console.error(`[SingleAI] Failed to reset ${instanceKey}:`, e);
            }
        });
        return;
    }

    services.forEach(service => {
        if (views[service]) {
            const url = getServiceResetUrl(service);

            // Clear cached URL for this service
            delete lastKnownMultiUrls[service];
            console.log(`[MultiAI] Cleared lastKnownMultiUrls[${service}] for new chat`);

            console.log(`Resetting chat for ${service} to ${url}`);
            if (views[service].view && !views[service].view.webContents.isDestroyed()) {
                views[service].view.webContents.loadURL(url);
            }
        }
    });
});

ipcMain.on('new-chat-for-service', (event, service) => {
    if (views[service]) {
        const url = getServiceResetUrl(service);

        // Clear cached URL for this service
        delete lastKnownMultiUrls[service];
        console.log(`[MultiAI] Cleared lastKnownMultiUrls[${service}] for new chat`);

        console.log(`Resetting chat for ${service} to ${url}`);
        if (views[service].view && !views[service].view.webContents.isDestroyed()) {
            views[service].view.webContents.loadURL(url);
        }
    }
});

ipcMain.on('reload-service', (event, service) => {
    if (views[service] && views[service].enabled) {
        console.log(`Reloading ${service}`);
        views[service].view.webContents.reload();
    }
});

// Navigate a specific service to a URL (for session restoration)
ipcMain.on('navigate-to-url', (event, service, url) => {
    if (views[service] && views[service].view && !views[service].view.webContents.isDestroyed()) {
        console.log(`Navigating ${service} to ${url}`);
        views[service].view.webContents.loadURL(url);
    }
});

// Open URL in external browser (URLBAR-005)
ipcMain.on('open-url-in-chrome', (event, url) => {
    if (url) {
        console.log(`Opening URL in external browser: ${url}`);
        shell.openExternal(url);
    }
});

// Helper to extract FULL conversation thread from a service (for Copy Chat Thread)
async function extractContentFromService(service, options = {}) {
    const wcOverride = options && options.__wcOverride ? options.__wcOverride : null;
    if (!wcOverride) {
        if (!views[service] || !views[service].enabled) return null;
    }

    const config = selectorsConfig[service];
    if (!config) return null;

    let content = null;
    let method = 'none';
    const wc = wcOverride || views[service].view.webContents;

    try {
        // Service-specific extraction scripts based on reference exporters
        let script;

        if (service === 'chatgpt') {
            // ChatGPT: Use article[data-testid^="conversation-turn-"] with h5.sr-only (user) and h6.sr-only (AI)
            script = `
                (function() {
                    const turns = document.querySelectorAll('article[data-testid^="conversation-turn-"]');
                    if (turns.length === 0) return null;
                    
                    let markdown = '';
                    turns.forEach((turn, i) => {
                        // User message
                        const userHeading = turn.querySelector('h5.sr-only');
                        if (userHeading) {
                            const userDiv = userHeading.nextElementSibling;
                            if (userDiv) {
                                const userQuery = userDiv.innerText.trim();
                                if (userQuery) {
                                    markdown += '## 👤 User\\n\\n' + userQuery + '\\n\\n';
                                }
                            }
                        }
                        
                        // AI message
                        const modelHeading = turn.querySelector('h6.sr-only');
                        if (modelHeading) {
                            const modelDiv = turn.querySelector('.markdown');
                            if (modelDiv) {
                                markdown += '## 🤖 ChatGPT\\n\\n' + modelDiv.innerHTML + '\\n\\n';
                            }
                        }
                        
                        markdown += '---\\n\\n';
                    });
                    return markdown;
                })();
            `;
        } else if (service === 'claude') {
            // Claude: Use actual DOM selectors from user-provided HTML
            // User messages: [data-testid="user-message"] with .whitespace-pre-wrap
            // AI responses: [data-is-streaming] with .standard-markdown
            script = `
                (function() {
                    let markdown = '';
                    
                    // Get all user messages - look for the actual message content
                    const userMessages = document.querySelectorAll('[data-testid="user-message"]');
                    // Get all AI responses - look for streaming containers
                    const aiResponses = document.querySelectorAll('[data-is-streaming]');
                    
                    // Debug: log what we found
                    console.log('Claude extraction - userMessages:', userMessages.length, 'aiResponses:', aiResponses.length);
                    
                    if (userMessages.length === 0 && aiResponses.length === 0) {
                        // Fallback: try to find messages in the main content area
                        // Look for the conversation container (not sidebar)
                        const mainArea = document.querySelector('.flex-1.flex.flex-col');
                        if (mainArea) {
                            // Find user bubbles (bg-bg-300 rounded-xl)
                            const userBubbles = mainArea.querySelectorAll('div.bg-bg-300.rounded-xl .whitespace-pre-wrap');
                            // Find AI responses (font-claude-response)
                            const aiBlocks = mainArea.querySelectorAll('.font-claude-response .standard-markdown');
                            
                            console.log('Claude fallback - userBubbles:', userBubbles.length, 'aiBlocks:', aiBlocks.length);
                            
                            if (userBubbles.length > 0 || aiBlocks.length > 0) {
                                const allTurns = [];
                                
                                userBubbles.forEach(el => {
                                    const rect = el.getBoundingClientRect();
                                    allTurns.push({ type: 'user', content: el.innerText.trim(), top: rect.top });
                                });
                                
                                aiBlocks.forEach(el => {
                                    const rect = el.getBoundingClientRect();
                                    allTurns.push({ type: 'ai', content: el.innerHTML, top: rect.top });
                                });
                                
                                allTurns.sort((a, b) => a.top - b.top);
                                
                                allTurns.forEach(turn => {
                                    if (turn.type === 'user') {
                                        markdown += '## 👤 User\\n\\n' + turn.content + '\\n\\n---\\n\\n';
                                    } else {
                                        markdown += '## 🤖 Claude\\n\\n' + turn.content + '\\n\\n---\\n\\n';
                                    }
                                });
                                
                                return markdown || null;
                            }
                        }
                        return null;
                    }
                    
                    // Collect all messages with their positions
                    const allTurns = [];
                    
                    userMessages.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        const textEl = el.querySelector('.whitespace-pre-wrap') || el;
                        allTurns.push({ 
                            type: 'user', 
                            content: textEl.innerText.trim(), 
                            top: rect.top 
                        });
                    });
                    
                    aiResponses.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        // Get ALL markdown content sections from the response
                        // Claude responses can have multiple .standard-markdown sections plus artifact blocks
                        const container = el.closest('.font-claude-response') || el;
                        
                        // Collect all standard-markdown sections
                        const markdownSections = container.querySelectorAll('.standard-markdown');
                        
                        // Collect artifact block descriptions
                        const artifactBlocks = container.querySelectorAll('.artifact-block-cell, [class*="artifact"]');
                        
                        let combinedContent = '';
                        
                        // Add all markdown sections
                        if (markdownSections.length > 0) {
                            markdownSections.forEach(section => {
                                combinedContent += section.innerHTML + '\\n\\n';
                            });
                        } else {
                            // Fallback to font-claude-response or direct content
                            const fallbackEl = el.querySelector('.font-claude-response') || el;
                            combinedContent = fallbackEl.innerHTML;
                        }
                        
                        // Add artifact information if present
                        artifactBlocks.forEach(artifact => {
                            const title = artifact.querySelector('.line-clamp-1, [class*="title"]');
                            const type = artifact.querySelector('.text-text-400, [class*="type"]');
                            if (title) {
                                combinedContent += '\\n\\n**[Artifact: ' + (title.textContent || 'Untitled').trim() + ']**';
                                if (type) {
                                    combinedContent += ' (' + type.textContent.trim() + ')';
                                }
                            }
                        });
                        
                        allTurns.push({ 
                            type: 'ai', 
                            content: combinedContent.trim(), 
                            top: rect.top 
                        });
                    });
                    
                    // Sort by vertical position to maintain conversation order
                    allTurns.sort((a, b) => a.top - b.top);
                    
                    allTurns.forEach(turn => {
                        if (turn.type === 'user') {
                            markdown += '## 👤 User\\n\\n' + turn.content + '\\n\\n---\\n\\n';
                        } else {
                            markdown += '## 🤖 Claude\\n\\n' + turn.content + '\\n\\n---\\n\\n';
                        }
                    });
                    
                    return markdown || null;
                })();
            `;
        } else if (service === 'gemini') {
            // Gemini: Use user-query and model-response custom tags (from reference)
            script = `
                (function() {
                    const turns = document.querySelectorAll('user-query, model-response');
                    if (turns.length === 0) return null;
                    
                    let markdown = '';
                    turns.forEach(turn => {
                        if (turn.tagName.toLowerCase() === 'user-query') {
                            const queryText = turn.querySelector('.query-text');
                            if (queryText) {
                                markdown += '## 👤 User\\n\\n' + queryText.innerText.trim() + '\\n\\n---\\n\\n';
                            }
                        } else if (turn.tagName.toLowerCase() === 'model-response') {
                            const responseEl = turn.querySelector('.markdown');
                            if (responseEl) {
                                markdown += '## 🤖 Gemini\\n\\n' + responseEl.innerHTML + '\\n\\n---\\n\\n';
                            }
                        }
                    });
                    return markdown || null;
                })();
            `;
        } else if (service === 'perplexity') {
            // Perplexity: Look for question and answer blocks
            script = `
                (function() {
                    // Try to find conversation turns
                    const container = document.querySelector('main');
                    if (!container) return null;
                    
                    // Perplexity uses various class patterns for questions and answers
                    const questions = container.querySelectorAll('[class*="query"], [class*="question"], .text-base.font-medium');
                    const answers = container.querySelectorAll('.prose, [class*="answer"], [class*="response"]');
                    
                    const allItems = [];
                    
                    questions.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        if (el.innerText.trim().length > 0) {
                            allItems.push({ type: 'user', el, top: rect.top, content: el.innerText.trim() });
                        }
                    });
                    
                    answers.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        if (el.innerHTML.trim().length > 0) {
                            allItems.push({ type: 'ai', el, top: rect.top, content: el.innerHTML });
                        }
                    });
                    
                    allItems.sort((a, b) => a.top - b.top);
                    
                    // Dedupe consecutive same-type items
                    let markdown = '';
                    let lastType = null;
                    allItems.forEach(item => {
                        if (item.type !== lastType) {
                            if (item.type === 'user') {
                                markdown += '## 👤 User\\n\\n' + item.content + '\\n\\n---\\n\\n';
                            } else {
                                markdown += '## 🤖 Perplexity\\n\\n' + item.content + '\\n\\n---\\n\\n';
                            }
                            lastType = item.type;
                        }
                    });
                    
                    return markdown || null;
                })();
            `;
        } else if (service === 'grok') {
            // Grok: User messages have items-end class, AI responses have items-start class
            // Container: div[id^="response-"] with .message-bubble containing content
            script = `
                (function() {
                    let markdown = '';
                    
                    // Find all response containers
                    const responseContainers = document.querySelectorAll('div[id^="response-"]');
                    
                    if (responseContainers.length === 0) return null;
                    
                    const allTurns = [];
                    
                    responseContainers.forEach(container => {
                        const rect = container.getBoundingClientRect();
                        const messageBubble = container.querySelector('.message-bubble');
                        if (!messageBubble) return;
                        
                        const contentEl = messageBubble.querySelector('.response-content-markdown') || messageBubble;
                        const content = contentEl.innerHTML;
                        
                        // Check if this is a user message (items-end) or AI response (items-start)
                        const isUser = container.classList.contains('items-end');
                        
                        if (content.trim()) {
                            allTurns.push({
                                type: isUser ? 'user' : 'ai',
                                content: isUser ? contentEl.innerText.trim() : content,
                                top: rect.top
                            });
                        }
                    });
                    
                    // Sort by position
                    allTurns.sort((a, b) => a.top - b.top);
                    
                    allTurns.forEach(turn => {
                        if (turn.type === 'user') {
                            markdown += '## \ud83d\udc64 User\\n\\n' + turn.content + '\\n\\n---\\n\\n';
                        } else {
                            markdown += '## \ud83e\udd16 Grok\\n\\n' + turn.content + '\\n\\n---\\n\\n';
                        }
                    });
                    
                    return markdown || null;
                })();
            `;
        }

        const rawContent = await wc.executeJavaScript(script);

        if (rawContent) {
            // The service-specific scripts return pre-formatted markdown with HTML in AI responses
            // We need to convert only the HTML parts to markdown, not the entire structure
            const turndownService = new TurndownService({
                headingStyle: 'atx',
                codeBlockStyle: 'fenced'
            });
            turndownService.use(gfm);

            // Remove noise elements
            turndownService.remove('button');
            turndownService.remove('style');
            turndownService.remove('script');
            turndownService.remove('nav');
            turndownService.remove('aside');
            turndownService.remove('svg');

            // Add rule to remove specific noise patterns
            turndownService.addRule('removeNoisePatterns', {
                filter: function (node) {
                    if (node.nodeName === 'SPAN' || node.nodeName === 'DIV') {
                        const text = node.innerText ? node.innerText.trim() : '';
                        const noisePatterns = [
                            'Copy code', '코드 복사', 'Copy', 'Copied!',
                            'python', 'javascript', 'typescript', 'html', 'css', 'bash', 'sql', 'json'
                        ];
                        if (noisePatterns.includes(text) && node.childNodes.length <= 1) {
                            return true;
                        }
                    }
                    return false;
                },
                replacement: function () {
                    return '';
                }
            });

            // Process each section: convert HTML content while preserving markdown headers
            // The rawContent has structure like: ## 👤 User\n\ntext\n\n---\n\n## 🤖 Service\n\n<html>\n\n---
            // We need to convert only the <html> parts
            const sections = rawContent.split(/(?=## [👤🤖])/);
            let processedContent = '';

            for (const section of sections) {
                if (!section.trim()) continue;

                // Check if this section contains HTML (AI responses have innerHTML)
                if (section.includes('<') && section.includes('>')) {
                    // Find the header part and content part
                    const headerMatch = section.match(/^(## [🤖👤][^\n]+\n\n)/);
                    if (headerMatch) {
                        const header = headerMatch[1];
                        let htmlContent = section.substring(header.length);

                        // Remove the trailing ---\n\n if present
                        const separatorIndex = htmlContent.lastIndexOf('---');
                        let separator = '';
                        if (separatorIndex !== -1) {
                            separator = htmlContent.substring(separatorIndex);
                            htmlContent = htmlContent.substring(0, separatorIndex);
                        }

                        // Convert HTML to markdown
                        const converted = turndownService.turndown(htmlContent.trim());
                        processedContent += header + converted + '\n\n' + separator;
                    } else {
                        // No header found, just convert the whole section
                        processedContent += turndownService.turndown(section);
                    }
                } else {
                    // No HTML, keep as-is (user messages with plain text)
                    processedContent += section;
                }
            }

            content = processedContent || rawContent;
            method = 'service-specific';
        }
    } catch (e) {
        console.warn(`Service-specific extraction failed for ${service}:`, e);
    }

    // Fallback: Try to get the main content area
    if (!content) {
        try {
            const containerSelectors = config.conversationContainerSelector || config.contentSelector || [];
            const script = `
                (function() {
                    const selectors = ${JSON.stringify(containerSelectors)};
                    for (const selector of selectors) {
                        const el = document.querySelector(selector);
                        if (el) {
                            return el.innerHTML;
                        }
                    }
                    return null;
                })();
            `;

            const html = await wc.executeJavaScript(script);

            if (html) {
                const turndownService = new TurndownService({
                    headingStyle: 'atx',
                    codeBlockStyle: 'fenced'
                });
                turndownService.use(gfm);
                turndownService.remove('button');
                turndownService.remove('style');
                turndownService.remove('script');
                turndownService.remove('nav');
                turndownService.remove('aside');

                content = turndownService.turndown(html);
                method = 'fallback';
            }
        } catch (e) {
            console.warn(`Fallback extraction failed for ${service}:`, e);
        }
    }

    // Final fallback: innerText
    if (!content) {
        try {
            const contentSelectors = config.contentSelector || [];
            const script = `
                (function() {
                    const selectors = ${JSON.stringify(contentSelectors)};
                    for (const selector of selectors) {
                        const el = document.querySelector(selector);
                        if (el) {
                            return el.innerText;
                        }
                    }
                    return document.body.innerText;
                })();
            `;

            content = await Promise.race([
                wc.executeJavaScript(script),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 2000))
            ]);
            method = 'text';
        } catch (e) {
            console.error(`Error extracting text from ${service}:`, e);
            content = `[Error extracting content: ${e.message}]`;
            method = 'error';
        }
    }

    return { service, content, method };
}

function getEnabledSingleInstances() {
    return Object.entries(singleModeViews)
        .filter(([_, v]) => v && v.enabled && v.view && !v.view.webContents.isDestroyed())
        .map(([instanceKey, v]) => ({
            instanceKey,
            service: v.service,
            instanceIndex: v.instanceIndex,
            wc: v.view.webContents
        }));
}

// Helper to extract ONLY the last AI response from a service (for Cross Check)
async function extractLastResponseFromService(service, options = {}) {
    const wcOverride = options && options.__wcOverride ? options.__wcOverride : null;
    if (!wcOverride) {
        if (!views[service] || !views[service].enabled) return null;
    }

    const config = selectorsConfig[service];
    if (!config) return null;

    let content = null;
    let method = 'none';
    const wc = wcOverride || views[service].view.webContents;

    // Service-specific overrides
    if (service === 'claude') {
        try {
            const script = `
                (function() {
                    // Get all AI responses
                    const aiResponses = document.querySelectorAll('[data-is-streaming], .font-claude-message');
                    
                    if (aiResponses.length === 0) {
                        // Backup check for just standard markdown blocks in deep structure
                        const deepMarkdown = document.querySelectorAll('.font-claude-response .standard-markdown');
                        if (deepMarkdown.length > 0) {
                            // This is harder to isolate to "last response" without a container, 
                            // so we'll rely on the main selectors first.
                            return null;
                        }
                        return null;
                    }
                    
                    // Get the last one
                    const lastResponse = aiResponses[aiResponses.length - 1];
                    
                    // Extract content similar to the full thread extraction
                    // 1. Get container
                    const container = lastResponse.closest('.font-claude-response') || lastResponse;
                    
                    // 2. Get markdown sections
                    const markdownSections = container.querySelectorAll('.standard-markdown');
                    
                    // 3. Get artifact blocks
                    const artifactBlocks = container.querySelectorAll('.artifact-block-cell, [class*="artifact"]');
                    
                    let combinedContent = '';
                    
                    if (markdownSections.length > 0) {
                        markdownSections.forEach(section => {
                            combinedContent += section.innerHTML + '\\n\\n';
                        });
                    } else {
                        // Fallback
                        const fallbackEl = lastResponse.querySelector('.font-claude-response') || lastResponse;
                        combinedContent = fallbackEl.innerHTML;
                    }
                    
                    // Add artifacts
                    artifactBlocks.forEach(artifact => {
                        const title = artifact.querySelector('.line-clamp-1, [class*="title"]');
                        const type = artifact.querySelector('.text-text-400, [class*="type"]');
                        if (title) {
                            combinedContent += '\\n\\n**[Artifact: ' + (title.textContent || 'Untitled').trim() + ']**';
                            if (type) {
                                combinedContent += ' (' + type.textContent.trim() + ')';
                            }
                        }
                    });
                    
                    return combinedContent.trim() || null;
                })();
            `;

            const html = await wc.executeJavaScript(script);

            if (html) {
                const turndownService = new TurndownService({
                    headingStyle: 'atx',
                    codeBlockStyle: 'fenced'
                });
                turndownService.use(gfm);
                turndownService.remove('button');
                turndownService.remove('style');
                turndownService.remove('script');

                content = turndownService.turndown(html);
                return { service, content, method: 'claude-custom' };
            }
        } catch (e) {
            console.warn('Claude specific extraction failed, falling back to generic:', e);
        }
    }

    // Try lastResponseSelector first
    const lastResponseSelectors = config.lastResponseSelector || [];

    if (lastResponseSelectors.length > 0) {
        try {
            const script = `
                (function() {
                    const selectors = ${JSON.stringify(lastResponseSelectors)};
                    for (const selector of selectors) {
                        // Use querySelectorAll and get the last match
                        const elements = document.querySelectorAll(selector);
                        if (elements.length > 0) {
                            const lastEl = elements[elements.length - 1];
                            return lastEl.innerHTML;
                        }
                    }
                    return null;
                })();
            `;

            const html = await wc.executeJavaScript(script);

            if (html) {
                const turndownService = new TurndownService({
                    headingStyle: 'atx',
                    codeBlockStyle: 'fenced'
                });
                turndownService.use(gfm);

                // Remove noise elements
                turndownService.remove('button');
                turndownService.remove('style');
                turndownService.remove('script');
                turndownService.remove('nav');
                turndownService.remove('aside');

                // Add rule to remove specific noise patterns
                turndownService.addRule('removeNoisePatterns', {
                    filter: function (node) {
                        if (node.nodeName === 'SPAN' || node.nodeName === 'DIV') {
                            const text = node.innerText ? node.innerText.trim() : '';
                            const noisePatterns = [
                                'Copy code', '코드 복사', 'Copy', 'Copied!',
                                'python', 'javascript', 'typescript', 'html', 'css', 'bash', 'sql', 'json'
                            ];
                            if (noisePatterns.includes(text) && node.childNodes.length <= 1) {
                                return true;
                            }
                        }
                        return false;
                    },
                    replacement: function () {
                        return '';
                    }
                });

                content = turndownService.turndown(html);
                method = 'lastResponse';
            }
        } catch (e) {
            console.warn(`Last response extraction failed for ${service}:`, e);
        }
    }

    // Fallback: use markdownContainerSelector and get last message
    if (!content && config.markdownContainerSelector && config.markdownContainerSelector.length > 0) {
        try {
            const script = `
                (function() {
                    const selectors = ${JSON.stringify(config.markdownContainerSelector)};
                    for (const selector of selectors) {
                        const elements = document.querySelectorAll(selector);
                        if (elements.length > 0) {
                            const lastEl = elements[elements.length - 1];
                            return lastEl.innerHTML;
                        }
                    }
                    return null;
                })();
            `;

            const html = await wc.executeJavaScript(script);

            if (html) {
                const turndownService = new TurndownService({
                    headingStyle: 'atx',
                    codeBlockStyle: 'fenced'
                });
                turndownService.use(gfm);
                turndownService.remove('button');
                turndownService.remove('style');
                turndownService.remove('script');

                content = turndownService.turndown(html);
                method = 'turndown-fallback';
            }
        } catch (e) {
            console.warn(`Fallback extraction failed for ${service}:`, e);
        }
    }

    // Final fallback: innerText of last response-like element
    if (!content) {
        try {
            const script = `
                (function() {
                    // Try common patterns for AI responses
                    const patterns = [
                        '[data-message-author-role="assistant"]',
                        '.assistant',
                        '[class*="response"]',
                        '[class*="answer"]',
                        '.prose'
                    ];
                    for (const pattern of patterns) {
                        const elements = document.querySelectorAll(pattern);
                        if (elements.length > 0) {
                            return elements[elements.length - 1].innerText;
                        }
                    }
                    return null;
                })();
            `;

            content = await Promise.race([
                wc.executeJavaScript(script),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 2000))
            ]);
            method = 'text-fallback';
        } catch (e) {
            console.error(`Error extracting last response from ${service}:`, e);
            content = null;
            method = 'error';
        }
    }

    return { service, content, method };
}

ipcMain.on('copy-chat-thread', async (event, options = {}) => {
    const { format = 'markdown', anonymousMode = false } = options;

    // Single AI Mode: copy across enabled instances
    if (chatMode === 'single' && singleAiService) {
        const enabledInstances = getEnabledSingleInstances().sort((a, b) => a.instanceIndex - b.instanceIndex);
        const promises = enabledInstances.map(inst =>
            extractContentFromService(inst.service, { format, __wcOverride: inst.wc })
                .then(r => (r ? { ...r, instanceKey: inst.instanceKey, instanceIndex: inst.instanceIndex } : null))
        );
        const results = (await Promise.all(promises)).filter(Boolean);

        const aliases = ['(A)', '(B)', '(C)', '(D)'];
        let finalOutput = '';

        if (format === 'json') {
            const jsonOutput = results.map(r => ({
                instance: anonymousMode ? (aliases[r.instanceIndex] || `(${r.instanceIndex})`) : `#${r.instanceIndex + 1}`,
                service: r.service,
                content: r.content,
                method: r.method,
                timestamp: new Date().toISOString()
            }));
            finalOutput = JSON.stringify(jsonOutput, null, 2);
        } else {
            results.forEach(r => {
                const label = anonymousMode ? (aliases[r.instanceIndex] || `(${r.instanceIndex})`) : `#${r.instanceIndex + 1}`;
                const title = `${r.service.toUpperCase()} ${label}`;
                if (format === 'markdown') {
                    finalOutput += `# ${title}\n\n${r.content}\n\n---\n\n`;
                } else {
                    finalOutput += `=== ${title} ===\n${r.content}\n\n${'-'.repeat(40)}\n\n`;
                }
            });
        }

        if (finalOutput) {
            clipboard.writeText(finalOutput);
            if (mainWindow) {
                mainWindow.webContents.send('chat-thread-copied', {
                    success: results.map(r => r.instanceKey),
                    failed: [],
                    format
                });
            }
        }
        return;
    }

    // Multi AI Mode
    const enabledServices = services.filter(service => views[service] && views[service].enabled);
    const promises = enabledServices.map(service => extractContentFromService(service, { format }));
    const results = await Promise.all(promises);

    // Format and combine
    let finalOutput = '';
    const aliases = {
        'chatgpt': 'Service A',
        'claude': 'Service B',
        'gemini': 'Service C',
        'grok': 'Service D',
        'perplexity': 'Service E',
        'genspark': 'Service F'
    };

    // Sort results by service order
    results.sort((a, b) => services.indexOf(a.service) - services.indexOf(b.service));

    if (format === 'json') {
        const jsonOutput = results.map(r => ({
            service: anonymousMode ? (aliases[r.service] || r.service) : r.service,
            content: r.content,
            method: r.method,
            timestamp: new Date().toISOString()
        }));
        finalOutput = JSON.stringify(jsonOutput, null, 2);
    } else {
        // Markdown or Text
        results.forEach(result => {
            if (result && result.content) {
                let serviceName = result.service.charAt(0).toUpperCase() + result.service.slice(1);
                let content = result.content;

                if (anonymousMode) {
                    serviceName = aliases[result.service] || serviceName;
                    // Simple anonymization of content (can be improved)
                    Object.keys(aliases).forEach(key => {
                        const regex = new RegExp(key, 'gi');
                        content = content.replace(regex, aliases[key]);
                    });
                }

                if (format === 'markdown') {
                    finalOutput += `# ${serviceName}\n\n${content}\n\n---\n\n`;
                } else {
                    finalOutput += `=== ${serviceName.toUpperCase()} ===\n${content}\n\n${'-'.repeat(40)}\n\n`;
                }
            } else {
                errors.push(result.service);
            }
        });
    }

    if (finalOutput) {
        clipboard.writeText(finalOutput);
        console.log('Chat threads copied to clipboard');

        // Granular feedback
        const successServices = results.filter(r => r.content).map(r => r.service);
        const failedServices = results.filter(r => !r.content).map(r => r.service);

        if (mainWindow) {
            mainWindow.webContents.send('chat-thread-copied', {
                success: successServices,
                failed: failedServices,
                format
            });
        }
    }
});

// Copy single service chat thread
ipcMain.on('copy-single-chat-thread', async (event, service, options = {}) => {
    const { format = 'markdown', anonymousMode = false } = options;

    // Support both:
    // - Multi AI Mode: `service` is provider key (chatgpt/claude/...)
    // - Single AI Mode: `service` can be instanceKey (e.g. chatgpt-0)
    const isInstanceKey = typeof service === 'string' && /-\d$/.test(service);
    let result = null;

    if (isInstanceKey && singleModeViews[service] && singleModeViews[service].enabled) {
        const inst = singleModeViews[service];
        result = await extractContentFromService(inst.service, { format, __wcOverride: inst.view.webContents });
    } else {
        if (!views[service] || !views[service].enabled) {
            if (mainWindow) {
                mainWindow.webContents.send('single-chat-thread-copied', { service, success: false });
            }
            return;
        }
        result = await extractContentFromService(service, { format });
    }

    if (result && result.content) {
        const aliases = {
            'chatgpt': 'Service A',
            'claude': 'Service B',
            'gemini': 'Service C',
            'grok': 'Service D',
            'perplexity': 'Service E',
            'genspark': 'Service F'
        };

        let finalOutput = '';
        let serviceName = service.charAt(0).toUpperCase() + service.slice(1);
        let content = result.content;

        if (anonymousMode) {
            serviceName = aliases[service] || serviceName;
            Object.keys(aliases).forEach(key => {
                const regex = new RegExp(key, 'gi');
                content = content.replace(regex, aliases[key]);
            });
        }

        if (format === 'json') {
            finalOutput = JSON.stringify({
                service: anonymousMode ? aliases[service] : service,
                content: content,
                method: result.method,
                timestamp: new Date().toISOString()
            }, null, 2);
        } else if (format === 'markdown') {
            finalOutput = `# ${serviceName}\n\n${content}`;
        } else {
            finalOutput = `=== ${serviceName.toUpperCase()} ===\n${content}`;
        }

        clipboard.writeText(finalOutput);
        console.log(`Single chat thread copied from ${service}`);

        if (mainWindow) {
            mainWindow.webContents.send('single-chat-thread-copied', { service, success: true, format });
        }
    } else {
        if (mainWindow) {
            mainWindow.webContents.send('single-chat-thread-copied', { service, success: false });
        }
    }
});

// Copy last response from ALL active services
ipcMain.on('copy-last-response', async (event, options = {}) => {
    const { format = 'markdown', anonymousMode = false } = options;

    if (chatMode === 'single' && singleAiService) {
        const enabledInstances = getEnabledSingleInstances().sort((a, b) => a.instanceIndex - b.instanceIndex);
        const promises = enabledInstances.map(inst =>
            extractLastResponseFromService(inst.service, { __wcOverride: inst.wc })
                .then(r => (r ? { ...r, instanceKey: inst.instanceKey, instanceIndex: inst.instanceIndex } : null))
        );
        const results = (await Promise.all(promises)).filter(Boolean);

        const aliases = ['(A)', '(B)', '(C)', '(D)'];
        let finalOutput = '';

        if (format === 'json') {
            const jsonOutput = results.filter(r => r && r.content).map(r => ({
                instance: anonymousMode ? (aliases[r.instanceIndex] || `(${r.instanceIndex})`) : `#${r.instanceIndex + 1}`,
                service: r.service,
                content: r.content,
                method: r.method,
                timestamp: new Date().toISOString()
            }));
            finalOutput = JSON.stringify(jsonOutput, null, 2);
        } else {
            results.forEach(r => {
                if (r && r.content) {
                    const label = anonymousMode ? (aliases[r.instanceIndex] || `(${r.instanceIndex})`) : `#${r.instanceIndex + 1}`;
                    const title = `${r.service.toUpperCase()} ${label}`;
                    if (format === 'markdown') {
                        finalOutput += `# ${title}\n\n${r.content}\n\n---\n\n`;
                    } else {
                        finalOutput += `=== ${title} ===\n${r.content}\n\n${'-'.repeat(40)}\n\n`;
                    }
                }
            });
        }

        if (finalOutput) {
            clipboard.writeText(finalOutput);
            if (mainWindow) {
                mainWindow.webContents.send('last-response-copied', {
                    success: results.filter(r => r && r.content).map(r => r.instanceKey),
                    failed: results.filter(r => !r || !r.content).map(r => r ? r.instanceKey : 'unknown'),
                    format
                });
            }
        }
        return;
    }

    const enabledServices = services.filter(service => views[service] && views[service].enabled);
    const promises = enabledServices.map(service => extractLastResponseFromService(service, {}));
    const results = await Promise.all(promises);

    const aliases = {
        'chatgpt': 'Service A',
        'claude': 'Service B',
        'gemini': 'Service C',
        'grok': 'Service D',
        'perplexity': 'Service E',
        'genspark': 'Service F'
    };

    results.sort((a, b) => services.indexOf(a.service) - services.indexOf(b.service));

    let finalOutput = '';

    if (format === 'json') {
        const jsonOutput = results.filter(r => r && r.content).map(r => ({
            service: anonymousMode ? (aliases[r.service] || r.service) : r.service,
            content: r.content,
            method: r.method,
            timestamp: new Date().toISOString()
        }));
        finalOutput = JSON.stringify(jsonOutput, null, 2);
    } else {
        results.forEach(result => {
            if (result && result.content) {
                let serviceName = result.service.charAt(0).toUpperCase() + result.service.slice(1);
                let content = result.content;

                if (anonymousMode) {
                    serviceName = aliases[result.service] || serviceName;
                    Object.keys(aliases).forEach(key => {
                        const regex = new RegExp(key, 'gi');
                        content = content.replace(regex, aliases[key]);
                    });
                }

                if (format === 'markdown') {
                    finalOutput += `# ${serviceName}\n\n${content}\n\n---\n\n`;
                } else {
                    finalOutput += `=== ${serviceName.toUpperCase()} ===\n${content}\n\n${'-'.repeat(40)}\n\n`;
                }
            }
        });
    }

    if (finalOutput) {
        clipboard.writeText(finalOutput);
        console.log('Last responses copied to clipboard');

        const successServices = results.filter(r => r && r.content).map(r => r.service);
        const failedServices = results.filter(r => !r || !r.content).map(r => r ? r.service : 'unknown');

        if (mainWindow) {
            mainWindow.webContents.send('last-response-copied', {
                success: successServices,
                failed: failedServices,
                format
            });
        }
    }
});

ipcMain.on('cross-check', async (event, isAnonymousMode, promptPrefix) => {
    console.log('Starting Cross Check... Anonymous:', isAnonymousMode, 'Prefix:', promptPrefix ? 'Yes' : 'No');

    if (chatMode === 'single' && singleAiService) {
        const enabledInstances = getEnabledSingleInstances().sort((a, b) => a.instanceIndex - b.instanceIndex);
        const aliases = ['(A)', '(B)', '(C)', '(D)'];

        // 1) Extract last response from each instance
        const results = {};
        for (const inst of enabledInstances) {
            const r = await extractLastResponseFromService(inst.service, { __wcOverride: inst.wc });
            if (r && r.content) {
                results[inst.instanceKey] = { content: r.content, instanceIndex: inst.instanceIndex };
            }
        }

        // 2) Construct and send prompt to each instance with others' responses
        const selectors = selectorsConfig[singleAiService];
        if (!selectors) return;

        for (const target of enabledInstances) {
            let prompt = '';
            if (promptPrefix) prompt += `${promptPrefix}\n\n`;

            for (const source of enabledInstances) {
                if (source.instanceKey === target.instanceKey) continue;
                const src = results[source.instanceKey];
                if (!src || !src.content) continue;

                const header = isAnonymousMode
                    ? (aliases[source.instanceIndex] || `(X)`)
                    : `#${source.instanceIndex + 1}`;
                prompt += `=== ${header} ===\n${src.content.trim()}\n\n`;
            }

            if (prompt) {
                try {
                    target.wc.send('inject-prompt', { text: prompt, selectors, autoSend: true });
                } catch (e) {
                    console.error(`[SingleAI] Cross-check send failed to ${target.instanceKey}:`, e);
                }
            }
        }
        return;
    }

    const aliases = {
        'chatgpt': '(A)',
        'claude': '(B)',
        'gemini': '(C)',
        'grok': '(D)',
        'perplexity': '(E)',
        'genspark': '(F)'
    };

    // 1. Extract LAST RESPONSE ONLY from each service
    const results = {};
    for (const service of services) {
        if (views[service] && views[service].enabled) {
            const result = await extractLastResponseFromService(service, {});
            if (result && result.content) {
                results[service] = result.content;
                console.log(`Cross Check: Extracted last response from ${service} (method: ${result.method})`);
            }
        }
    }

    // 2. Construct prompts and send
    for (const targetService of services) {
        if (views[targetService] && views[targetService].enabled) {
            let prompt = "";

            // Add Prefix if exists
            if (promptPrefix) {
                prompt += `${promptPrefix}\n\n`;
            }

            for (const sourceService of services) {
                if (sourceService !== targetService && results[sourceService]) {
                    let header = sourceService.toUpperCase();
                    let content = results[sourceService].trim();

                    if (isAnonymousMode) {
                        header = aliases[sourceService] || header;
                        // Replace all occurrences of service names in content
                        Object.entries(aliases).forEach(([svc, alias]) => {
                            // Create regex for case-insensitive match
                            const regex = new RegExp(svc, 'gi');
                            content = content.replace(regex, alias);
                        });
                    }

                    prompt += `=== ${header} ===\n${content}\n\n`;
                }
            }

            if (prompt) {
                const selectors = selectorsConfig[targetService];
                if (selectors) {
                    // Send with autoSend: true
                    views[targetService].view.webContents.send('inject-prompt', { text: prompt, selectors, autoSend: true });
                }
            }
        }
    }
});

// NOTE: legacy handler removed (duplicate channel name caused both listeners to fire).
// If you need raw-text copy in the future, add a new IPC channel name, e.g. 'copy-raw-text'.

// Scroll Sync State
let isScrollSyncEnabled = false;

ipcMain.on('toggle-scroll-sync', (event, isEnabled) => {
    isScrollSyncEnabled = isEnabled;
    // Broadcast to all views (multi + single)
    services.forEach(service => {
        if (views[service] && views[service].view) {
            views[service].view.webContents.send('scroll-sync-state', isScrollSyncEnabled);
        }
    });
    Object.keys(singleModeViews).forEach(instanceKey => {
        const v = singleModeViews[instanceKey];
        if (v && v.view && !v.view.webContents.isDestroyed()) {
            v.view.webContents.send('scroll-sync-state', isScrollSyncEnabled);
        }
    });
});

ipcMain.on('sync-scroll', (event, { deltaX, deltaY }) => {
    if (!isScrollSyncEnabled) return;

    // Broadcast to all OTHER views (multi + single)
    services.forEach(service => {
        if (views[service] && views[service].view) {
            // Don't send back to sender (optional optimization, but simple broadcast is fine if logic handles it)
            // But here we are in Main, we don't know easily which view sent it unless we check event.sender
            if (views[service].view.webContents !== event.sender) {
                views[service].view.webContents.send('apply-scroll', { deltaX, deltaY });
            }
        }
    });
    Object.keys(singleModeViews).forEach(instanceKey => {
        const v = singleModeViews[instanceKey];
        if (v && v.view && !v.view.webContents.isDestroyed()) {
            if (v.view.webContents !== event.sender) {
                v.view.webContents.send('apply-scroll', { deltaX, deltaY });
            }
        }
    });
});

ipcMain.on('zoom-sync', (event, direction) => {
    const zoomStep = 0.1;
    if (direction === 'in') {
        currentZoomLevel = Math.min(currentZoomLevel + zoomStep, 3.0); // Max 300%
    } else {
        currentZoomLevel = Math.max(currentZoomLevel - zoomStep, 0.5); // Min 50%
    }

    // Apply to all views
    services.forEach(service => {
        if (views[service] && views[service].view) {
            views[service].view.webContents.setZoomFactor(currentZoomLevel);
        }
    });
});

// External Login Handler
ipcMain.on('external-login', async (event, service) => {
    const axios = require('axios');

    console.log(`Launching Chrome for ${service} login...`);
    const isMac = process.platform === 'darwin'; // OS 확인 변수
    const isWin = process.platform === 'win32';

    try {
        // Helper: collect cookies relevant to each service (captures Google SSO cookies too)
        const collectLoginCookies = async (page, service) => {
            let cookies = [];
            try {
                cookies = await page.cookies();
            } catch (e) {
                console.warn('Failed to fetch page cookies:', e);
            }

            // Always try service base URL cookies explicitly (can differ from current URL)
            try {
                const serviceBaseCookies = await page.cookies(serviceUrls[service]);
                cookies = [...cookies, ...serviceBaseCookies];
            } catch (e) {
                // ignore
            }

            // Google-based login cookies
            if (service === 'gemini' || service === 'genspark') {
                try {
                    const googleCookies = await page.cookies(
                        'https://accounts.google.com',
                        'https://google.com',
                        'https://www.google.com'
                    );
                    cookies = [...cookies, ...googleCookies];
                } catch (e) {
                    console.warn(`Failed to fetch Google cookies for ${service}:`, e);
                }
            }

            // Genspark domain cookies can be separate from Google cookies
            if (service === 'genspark') {
                try {
                    const gsCookies = await page.cookies(
                        'https://www.genspark.ai',
                        'https://genspark.ai'
                    );
                    cookies = [...cookies, ...gsCookies];
                } catch (e) {
                    // ignore
                }
            }

            // Grok extra cookies (X + Google)
            if (service === 'grok') {
                try {
                    const extraCookies = await page.cookies(
                        'https://x.com',
                        'https://twitter.com',
                        'https://accounts.google.com',
                        'https://google.com'
                    );
                    cookies = [...cookies, ...extraCookies];
                } catch (e) {
                    console.warn('Failed to fetch extra cookies for Grok:', e);
                }
            }

            // Deduplicate by name+domain+path
            const seen = new Set();
            const unique = [];
            for (const c of cookies) {
                const key = `${c.name}|${c.domain || ''}|${c.path || ''}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    unique.push(c);
                }
            }
            return unique;
        };

        // Helper: determine "logged-in" for each service based on cookie presence
        const isAuthCookiePresent = (service, cookies) => {
            if (!Array.isArray(cookies) || cookies.length === 0) return false;

            if (service === 'chatgpt') {
                // Based on user image: __Secure-next-auth.session-token, oai-did, _cf_bm
                return cookies.some(c => c.name === '__Secure-next-auth.session-token' || c.name === 'oai-did');
            }
            if (service === 'claude') {
                return cookies.some(c => c.name === 'sessionKey');
            }
            if (service === 'gemini') {
                // Based on user image: SID, _Secure-1PSID, __Secure-1PSID, _Secure-3PSID, __Secure-3PSID
                // Check for both single and double underscore variants to handle different cookie formats
                return cookies.some(c =>
                    c.name === 'SID' ||
                    c.name === '_Secure-1PSID' || c.name === '__Secure-1PSID' ||
                    c.name === '_Secure-3PSID' || c.name === '__Secure-3PSID' ||
                    c.name === '_Secure-1PAPISID' || c.name === '__Secure-1PAPISID' ||
                    c.name === '_Secure-3PAPISID' || c.name === '__Secure-3PAPISID'
                );
            }
            if (service === 'grok') {
                return cookies.some(c => c.name.includes('sso') || c.name === 'auth_token' || c.name.includes('grok'));
            }
            if (service === 'perplexity') {
                return cookies.some(c => c.name === '__Secure-next-auth.session-token');
            }
            if (service === 'genspark') {
                // Genspark relies on Google Login, so check Google auth cookies
                return cookies.some(c => c.name === '__Secure-1PSID' || c.name === '__Secure-3PSID' || c.name === 'SID');
            }
            return false;
        };

        const syncCookiesToElectron = async (service, cookies) => {
            if (!views[service] || !views[service].view) return;
            const electronCookies = views[service].view.webContents.session.cookies;

            for (const cookie of cookies) {
                try {
                    // Determine URL based on cookie domain
                    let cookieUrl = serviceUrls[service];
                    if (cookie.domain) {
                        const cleanDomain = cookie.domain.startsWith('.') ? cookie.domain.substring(1) : cookie.domain;
                        cookieUrl = (cookie.secure ? 'https://' : 'http://') + cleanDomain + '/';
                    }

                    // Map SameSite to Electron-accepted values
                    const mapSameSite = (value, isSecure) => {
                        const normalized = (value || '').toLowerCase();
                        if (normalized === 'no_restriction' || normalized === 'none') return 'no_restriction';
                        if (normalized === 'lax') return 'lax';
                        if (normalized === 'strict') return 'strict';
                        // Fallback: match Chrome behavior (None requires secure)
                        return isSecure ? 'no_restriction' : 'lax';
                    };

                    const cookieDetails = {
                        url: cookieUrl,
                        name: cookie.name,
                        value: cookie.value,
                        domain: cookie.domain,
                        path: cookie.path || '/',
                        secure: cookie.secure,
                        httpOnly: cookie.httpOnly,
                        // Explicitly set SameSite policy for proper cookie context
                        sameSite: mapSameSite(cookie.sameSite, cookie.secure)
                    };

                    // Only set expirationDate for persistent cookies.
                    // Puppeteer uses -1 for session cookies; Electron expects a unix timestamp (seconds).
                    if (typeof cookie.expires === 'number' && cookie.expires > 0) {
                        cookieDetails.expirationDate = cookie.expires;
                    }

                    // Fix for __Host- prefix: Must NOT have a domain attribute
                    if (cookie.name.startsWith('__Host-')) {
                        delete cookieDetails.domain;
                    }

                    await electronCookies.set(cookieDetails);
                } catch (err) {
                    console.error(`Failed to set cookie ${cookie.name}:`, err?.message || err);
                }
            }
        };

        // 0. Cleanup existing Chrome instances (Mac specific)
        if (isMac) {
            try {
                const { execSync } = require('child_process');
                execSync('pkill -f "chrome-auth-profile"');
                console.log('Cleaned up existing Chrome instances');
            } catch (e) {
                // Ignore error if no process found
            }
        }

        // 1. Find Chrome Path
        const chromeLauncher = await import('chrome-launcher');
        const chromePath = chromeLauncher.Launcher.getInstallations()[0];
        if (!chromePath) {
            console.error('Chrome installation not found');
            return;
        }

        const puppeteer = require('puppeteer-extra');
        const StealthPlugin = require('puppeteer-extra-plugin-stealth');
        const stealth = StealthPlugin();

        puppeteer.use(stealth);

        // 2. Launch Chrome with Remote Debugging
        const launchArgs = [
            '--no-first-run',
            '--no-default-browser-check',
        ];

        // [Logic Merge] Apply automation flag to all platforms to avoid detection
        launchArgs.push('--disable-blink-features=AutomationControlled');

        // Launch Browser
        const browser = await puppeteer.launch({
            executablePath: chromePath,
            headless: false,
            defaultViewport: null,
            userDataDir: path.join(app.getPath('userData'), 'chrome-auth-profile'),
            ignoreDefaultArgs: ['--enable-automation'],
            args: launchArgs
        });

        const page = (await browser.pages())[0];

        // Track latest cookies so we can sync even if user closes Chrome quickly after login
        let lastSeenCookies = [];
        let lastAuthCookies = [];
        let didSyncCookies = false;
        // Track if user actually completed login in Chrome (not just had old cookies in profile)
        let loginConfirmedInChrome = false;

        // NOTE: We do NOT sync cookies on framenavigated anymore.
        // Problem: Chrome profile may have stale/invalid cookies from previous sessions.
        // If we sync on navigation, we may sync invalid cookies before user actually logs in.
        // Instead, we only sync when polling detects login AND user is on a non-login page.

        await page.goto(serviceUrls[service]);

        // Wait for page to stabilize before starting login detection.
        // This is CRITICAL for Google-based services (Gemini/Genspark):
        // - Chrome profile may have OLD/INVALID cookies from previous sessions
        // - If we check immediately, we might see those cookies + /app URL = false "login detected"
        // - But Chrome will redirect to login page within 1-2 seconds if cookies are invalid
        // - By waiting, we give Chrome time to redirect before we start checking
        const stabilizeDelay = (service === 'grok') ? 5000 : 
                               (service === 'gemini' || service === 'genspark') ? 3000 : 1000;
        console.log(`[${service}] Waiting ${stabilizeDelay}ms for page to stabilize...`);
        await new Promise(resolve => setTimeout(resolve, stabilizeDelay));

        // 3. Monitor for Login Success (Cookie Check)
        const checkLogin = setInterval(async () => {
            try {
                if (browser.process().killed) {
                    clearInterval(checkLogin);
                    return;
                }

                const cookies = await collectLoginCookies(page, service);
                lastSeenCookies = cookies;
                const isLoggedIn = isAuthCookiePresent(service, cookies);
                if (isLoggedIn) {
                    lastAuthCookies = cookies;
                }

                // Check URL to ensure we are on the actual service domain (not login pages)
                const url = page.url();
                // CRITICAL: For Google-based services, we must confirm Chrome is ON the service domain.
                // - accounts.google.com = still logging in, NOT confirmed
                // - gemini.google.com/app = on service, can confirm if cookies valid
                // - genspark.ai/... = on service, can confirm if cookies valid
                const isOnServiceDomain = (() => {
                    if (service === 'gemini') return url.includes('gemini.google.com');
                    if (service === 'genspark') return url.includes('genspark.ai');
                    if (service === 'chatgpt') return url.includes('chatgpt.com') || url.includes('chat.openai.com');
                    if (service === 'claude') return url.includes('claude.ai');
                    if (service === 'grok') return url.includes('grok.com') || url.includes('x.com');
                    if (service === 'perplexity') return url.includes('perplexity.ai');
                    return !url.includes('accounts.google.com');
                })();
                const isNotLoginPage = isOnServiceDomain && 
                    !url.includes('/auth/login') && 
                    !url.includes('/signin') &&
                    !url.includes('accounts.google.com') && 
                    !url.includes('sso');

                if (isLoggedIn && isNotLoginPage) {
                    clearInterval(checkLogin);
                    console.log(`${service} login detected in Chrome! Syncing cookies...`);

                    // Mark that login was actually confirmed in Chrome (not just stale profile cookies)
                    loginConfirmedInChrome = true;

                    // Sync cookies to Electron session
                    console.log(`[${service}] Syncing ${cookies.length} cookies...`);
                    await syncCookiesToElectron(service, cookies);
                    didSyncCookies = true;
                    console.log(`Cookies synced for ${service}`);

                    // Navigate to canonical service URL so DOM-based login detection updates immediately
                    const targetUrl = getServiceResetUrl(service);
                    if (views[service] && views[service].view) {
                        views[service].view.webContents.loadURL(targetUrl);
                    }

                    console.log(`${service} login confirmed! Keeping Chrome open for manual close...`);
                    // Do NOT close browser automatically. User will close it.
                }
            } catch (e) {
                clearInterval(checkLogin);
                console.error('Error checking login status:', e);
            }
        }, 1000);

        // Handle manual close
        browser.on('disconnected', async () => {
            clearInterval(checkLogin);
            console.log(`Chrome disconnected (closed by user). loginConfirmedInChrome=${loginConfirmedInChrome}`);

            if (views[service] && views[service].view) {
                // CRITICAL FIX: Only navigate app view to /app if login was ACTUALLY confirmed in Chrome.
                // Problem scenario:
                // 1. User logs out in app webview (Electron cookies cleared)
                // 2. Opens Chrome - Chrome profile may still have OLD Google cookies
                // 3. If we sync those old cookies and navigate to /app, they're invalid → stuck on login
                // 4. Second attempt works because user actually logged in, making cookies valid
                //
                // Solution: Only sync cookies and navigate to /app if polling detected actual login.
                if (loginConfirmedInChrome) {
                    // User actually completed login in Chrome - sync and navigate
                    if (!didSyncCookies && Array.isArray(lastAuthCookies) && lastAuthCookies.length > 0) {
                        console.log(`[${service}] Syncing confirmed auth cookies (${lastAuthCookies.length})...`);
                        try {
                            await syncCookiesToElectron(service, lastAuthCookies);
                            didSyncCookies = true;
                        } catch (e) {
                            // ignore
                        }
                    }

                    const targetUrl = getServiceResetUrl(service);
                    console.log(`[${service}] Login confirmed, loading: ${targetUrl}`);
                    views[service].view.webContents.loadURL(targetUrl);
                } else {
                    // User closed Chrome without completing login - just reload current view
                    // This keeps the app on whatever page it was (likely login page)
                    console.log(`[${service}] No login confirmed, reloading current view...`);
                    views[service].view.webContents.reload();
                }
            }

            if (mainWindow) {
                mainWindow.webContents.send('external-login-closed');
            }
        });

    } catch (e) {
        console.error('Error in external login:', e);
    }
});

ipcMain.on('reload-active-view', (event) => {
    // Reload only the view that requested it
    event.sender.reload();
});

// ===========================================
// Prompt Persistence (electron-store)
// ===========================================
ipcMain.handle('get-custom-prompts', async () => {
    try {
        return store.get(PROMPT_STORE_KEYS.customPrompts, []);
    } catch (e) {
        console.error('[Prompts] Failed to read custom prompts:', e);
        return [];
    }
});

ipcMain.handle('save-custom-prompts', async (event, prompts) => {
    try {
        if (Array.isArray(prompts)) {
            store.set(PROMPT_STORE_KEYS.customPrompts, prompts);
        }
        return true;
    } catch (e) {
        console.error('[Prompts] Failed to save custom prompts:', e);
        return false;
    }
});

ipcMain.handle('get-predefined-prompt', async () => {
    try {
        return store.get(PROMPT_STORE_KEYS.predefinedPrompt, null);
    } catch (e) {
        console.error('[Prompts] Failed to read predefined prompt:', e);
        return null;
    }
});

ipcMain.handle('save-predefined-prompt', async (event, promptText) => {
    try {
        if (typeof promptText === 'string') {
            store.set(PROMPT_STORE_KEYS.predefinedPrompt, promptText);
        }
        return true;
    } catch (e) {
        console.error('[Prompts] Failed to save predefined prompt:', e);
        return false;
    }
});

// ===========================================
// Chat Mode IPC Handlers (Single AI / Multi AI)
// ===========================================

ipcMain.handle('set-chat-mode', async (event, mode, config = {}) => {
    try {
        console.log(`[ChatMode] set-chat-mode called: mode=${mode}`, config);
        
        if (mode === 'single') {
            const { service, activeInstances: rawInstances = [true, true, true], urls = null } = config;
            // Ensure max SINGLE_MODE_MAX_INSTANCES
            const activeInstances = rawInstances.slice(0, SINGLE_MODE_MAX_INSTANCES);
            
            if (!service || !services.includes(service)) {
                console.error(`[ChatMode] Invalid service: ${service}`);
                return { success: false, error: 'Invalid service' };
            }
            switchToSingleAiMode(service, activeInstances, urls);
            return { success: true, mode: 'single', service, activeInstances };
        } else {
            switchToMultiAiMode();
            return { success: true, mode: 'multi' };
        }
    } catch (e) {
        console.error('[ChatMode] Error setting chat mode:', e);
        return { success: false, error: e.message };
    }
});

ipcMain.handle('get-chat-mode', async () => {
    return {
        mode: chatMode,
        service: singleAiService,
        activeInstances: singleAiActiveInstances
    };
});

// Return current URLs directly from BrowserView webContents using executeJavaScript for SPA accuracy
ipcMain.handle('get-current-urls', async () => {
    console.log('[Session] get-current-urls called, chatMode:', chatMode);
    console.log('[Session] lastKnownInstanceUrls:', JSON.stringify(lastKnownInstanceUrls));
    console.log('[Session] lastKnownMultiUrls:', JSON.stringify(lastKnownMultiUrls));
    
    // Helper: Check if URL is a conversation URL (not just base URL)
    const isConversationUrl = (url) => {
        if (!url || typeof url !== 'string') return false;
        return /\/c\/[a-f0-9-]+/i.test(url) ||       // ChatGPT
               /\/chat\/[a-f0-9-]+/i.test(url) ||    // Claude
               /conversation.*[a-f0-9-]{8,}/i.test(url) ||
               /\/share\/[a-f0-9-]+/i.test(url);
    };
    
    // Helper: Pick the best URL (prefer conversation URLs over base URLs)
    const pickBestUrl = (actualUrl, cachedUrl, wcUrl) => {
        // If actual URL is a conversation URL, use it
        if (isConversationUrl(actualUrl)) return actualUrl;
        // If cached URL is a conversation URL, prefer it over base actualUrl
        if (isConversationUrl(cachedUrl)) return cachedUrl;
        // Otherwise fall back to actualUrl or wcUrl
        return actualUrl || cachedUrl || wcUrl;
    };
    
    try {
        if (chatMode === 'single') {
            const urls = {};
            const entries = Object.entries(singleModeViews).filter(([_, v]) => 
                v && v.enabled && v.view && !v.view.webContents.isDestroyed()
            );
            
            console.log('[Session] Single mode entries count:', entries.length);
            
            // Use executeJavaScript to get actual location.href (handles SPA pushState)
            for (const [instanceKey, v] of entries) {
                try {
                    // Try to get actual location.href from page context
                    const actualUrl = await v.view.webContents.executeJavaScript('window.location.href', true);
                    const wcUrl = v.view.webContents.getURL();
                    const cachedUrl = lastKnownInstanceUrls[instanceKey];
                    
                    // Pick the best URL (prefer conversation URL)
                    const bestUrl = pickBestUrl(actualUrl, cachedUrl, wcUrl);
                    urls[instanceKey] = bestUrl;
                    
                    console.log(`[Session] ${instanceKey}: executeJS=${actualUrl}, cached=${cachedUrl}, picked=${bestUrl}`);
                    
                    // Update lastKnown only if we got a conversation URL
                    if (isConversationUrl(actualUrl)) {
                        lastKnownInstanceUrls[instanceKey] = actualUrl;
                    }
                } catch (e) {
                    console.error(`[Session] executeJavaScript failed for ${instanceKey}:`, e.message);
                    // Fallback if executeJavaScript fails
                    urls[instanceKey] = lastKnownInstanceUrls[instanceKey] || v.view.webContents.getURL();
                }
            }
            
            console.log('[Session] get-current-urls (single) result:', JSON.stringify(urls));
            return { mode: 'single', urls };
        }

        const urls = {};
        const activeServices = services.filter(service => 
            views[service] && views[service].enabled && views[service].view && !views[service].view.webContents.isDestroyed()
        );
        
        console.log('[Session] Multi mode active services:', activeServices);
        
        // Use executeJavaScript for Multi AI Mode as well
        for (const service of activeServices) {
            try {
                const actualUrl = await views[service].view.webContents.executeJavaScript('window.location.href', true);
                const wcUrl = views[service].view.webContents.getURL();
                const cachedUrl = lastKnownMultiUrls[service];
                
                const bestUrl = pickBestUrl(actualUrl, cachedUrl, wcUrl);
                urls[service] = bestUrl;
                
                console.log(`[Session] ${service}: executeJS=${actualUrl}, cached=${cachedUrl}, picked=${bestUrl}`);
                
                if (isConversationUrl(actualUrl)) {
                    lastKnownMultiUrls[service] = actualUrl;
                }
            } catch (e) {
                console.error(`[Session] executeJavaScript failed for ${service}:`, e.message);
                urls[service] = lastKnownMultiUrls[service] || views[service].view.webContents.getURL();
            }
        }
        
        console.log('[Session] get-current-urls (multi) result:', JSON.stringify(urls));
        return { mode: 'multi', urls };
    } catch (e) {
        console.error('[Session] get-current-urls failed:', e);
        return { mode: chatMode, urls: {} };
    }
});

// SPA-safe URL updates from service-preload (pushState/replaceState/popstate polling)
ipcMain.on('service-url-updated', (event, payload) => {
    try {
        const { service, instanceKey, url } = payload || {};
        console.log(`[URL] service-url-updated received: service=${service}, instanceKey=${instanceKey}, url=${url}`);
        if (!url) return;
        
        // Helper: Check if URL is a conversation URL
        const isConversationUrl = (u) => {
            if (!u || typeof u !== 'string') return false;
            return /\/c\/[a-f0-9-]+/i.test(u) ||       // ChatGPT
                   /\/chat\/[a-f0-9-]+/i.test(u) ||    // Claude
                   /conversation.*[a-f0-9-]{8,}/i.test(u) ||
                   /\/share\/[a-f0-9-]+/i.test(u);
        };
        
        if (instanceKey) {
            // Only update cache if new URL is a conversation URL OR if there's no cached URL
            const existingUrl = lastKnownInstanceUrls[instanceKey];
            const shouldUpdate = isConversationUrl(url) || !isConversationUrl(existingUrl);
            
            if (shouldUpdate) {
                console.log(`[URL] Storing in lastKnownInstanceUrls[${instanceKey}] = ${url}`);
                lastKnownInstanceUrls[instanceKey] = url;
            } else {
                console.log(`[URL] NOT storing base URL over conversation URL for ${instanceKey}. Keeping: ${existingUrl}`);
            }
            
            const viewObj = singleModeViews[instanceKey];
            const instanceIndex = viewObj?.instanceIndex;
            const svc = service || viewObj?.service;
            if (mainWindow && !mainWindow.isDestroyed()) {
                mainWindow.webContents.send('single-instance-url-changed', {
                    instanceKey,
                    service: svc,
                    instanceIndex,
                    url
                });
            }
        } else if (service) {
            // Only update cache if new URL is a conversation URL OR if there's no cached URL
            const existingUrl = lastKnownMultiUrls[service];
            const shouldUpdate = isConversationUrl(url) || !isConversationUrl(existingUrl);
            
            if (shouldUpdate) {
                console.log(`[URL] Storing in lastKnownMultiUrls[${service}] = ${url}`);
                lastKnownMultiUrls[service] = url;
            } else {
                console.log(`[URL] NOT storing base URL over conversation URL for ${service}. Keeping: ${existingUrl}`);
            }
            
            if (mainWindow && !mainWindow.isDestroyed()) {
                mainWindow.webContents.send('webview-url-changed', { service, url });
            }
        } else {
            console.log('[URL] No instanceKey or service provided, URL not stored');
        }
    } catch (e) {
        console.error('[URL] service-url-updated failed:', e);
    }
});

ipcMain.on('toggle-single-instance', (event, instanceIndex, enabled) => {
    console.log(`[ChatMode] toggle-single-instance: index=${instanceIndex}, enabled=${enabled}`);
    toggleSingleInstance(instanceIndex, enabled);
});

// Single AI Mode: Send prompt to instances
ipcMain.on('send-prompt-to-instances', async (event, text, instanceKeys, filePaths = []) => {
    console.log(`[SingleAI] Sending prompt to instances:`, instanceKeys, 'hasFiles:', filePaths?.length > 0);
    
    const hasFiles = filePaths && filePaths.length > 0;

    // Send sequentially with jitter to avoid "bot-like burst" behavior
    const orderedKeys = [...instanceKeys].sort();
    for (const instanceKey of orderedKeys) {
        const viewObj = singleModeViews[instanceKey];
        if (!(viewObj && viewObj.view && viewObj.enabled && !viewObj.view.webContents.isDestroyed())) {
            continue;
        }

        // Small stagger between instances
        await sleep(jitterMs(SINGLE_PROMPT_STAGGER_BASE_DELAY_MS, SINGLE_PROMPT_STAGGER_JITTER_MS));

        try {
            const service = viewObj.service;
            const selectors = selectorsConfig[service];

            if (!selectors) {
                console.error(`[SingleAI] No selectors config for service: ${service}`);
                continue;
            }

            const wc = viewObj.view.webContents;

            // 1) File uploads (if present)
            if (hasFiles && selectors.fileInputSelector) {
                try {
                    console.log(`[SingleAI] Uploading files to ${instanceKey}...`);
                    try {
                        wc.debugger.attach('1.3');
                    } catch (err) {
                        console.log(`[SingleAI] Debugger already attached for ${instanceKey}`);
                    }

                    await wc.debugger.sendCommand('DOM.enable');
                    const { root } = await wc.debugger.sendCommand('DOM.getDocument');

                    let nodeId = null;
                    for (const selector of selectors.fileInputSelector) {
                        try {
                            const result = await wc.debugger.sendCommand('DOM.querySelector', {
                                nodeId: root.nodeId,
                                selector: selector
                            });
                            if (result.nodeId) {
                                nodeId = result.nodeId;
                                break;
                            }
                        } catch (e) { /* ignore */ }
                    }

                    if (nodeId) {
                        await wc.debugger.sendCommand('DOM.setFileInputFiles', {
                            nodeId: nodeId,
                            files: filePaths
                        });
                        console.log(`[SingleAI] Files set for ${instanceKey}`);
                        await sleep(jitterMs(1400, 300));
                    } else {
                        console.warn(`[SingleAI] File input not found for ${instanceKey}`);
                    }

                    try { wc.debugger.detach(); } catch (e) { /* ignore */ }
                } catch (uploadErr) {
                    console.error(`[SingleAI] Error uploading files to ${instanceKey}:`, uploadErr);
                    try { wc.debugger.detach(); } catch (e) { /* ignore */ }
                }
            }

            // 2) Inject prompt
            wc.send('inject-prompt', { text, selectors, autoSend: !hasFiles });
            console.log(`[SingleAI] Sent prompt to ${instanceKey}`);

        } catch (e) {
            console.error(`[SingleAI] Failed to send to ${instanceKey}:`, e);
        }
    }
    
    if (hasFiles) {
        // Notify file upload complete
        event.sender.send('file-upload-complete');
    }
});

ipcMain.on('navigate-instance', (event, instanceKey, url) => {
    if (singleModeViews[instanceKey] && singleModeViews[instanceKey].view && 
        !singleModeViews[instanceKey].view.webContents.isDestroyed()) {
        console.log(`[SingleAI] Navigating ${instanceKey} to ${url}`);
        singleModeViews[instanceKey].view.webContents.loadURL(url);
    }
});

ipcMain.on('reload-instance', (event, instanceKey) => {
    if (singleModeViews[instanceKey] && singleModeViews[instanceKey].view &&
        singleModeViews[instanceKey].enabled && !singleModeViews[instanceKey].view.webContents.isDestroyed()) {
        console.log(`[SingleAI] Reloading ${instanceKey}`);
        singleModeViews[instanceKey].view.webContents.reload();
    }
});

ipcMain.on('new-chat-for-instance', (event, instanceKey) => {
    if (singleModeViews[instanceKey] && singleModeViews[instanceKey].view &&
        !singleModeViews[instanceKey].view.webContents.isDestroyed()) {
        const service = singleModeViews[instanceKey].service;
        const url = getServiceResetUrl(service);
        console.log(`[SingleAI] New chat for ${instanceKey}: ${url}`);
        singleModeViews[instanceKey].view.webContents.loadURL(url);
    }
});

// Update view bounds to handle Single AI Mode
ipcMain.on('update-single-view-bounds', (event, boundsMap) => {
    if (!mainWindow || chatMode !== 'single') return;

    Object.entries(boundsMap).forEach(([instanceKey, rect]) => {
        if (singleModeViews[instanceKey] && singleModeViews[instanceKey].view) {
            singleModeViews[instanceKey].view.setBounds({
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height
            });
        }
    });
});

ipcMain.on('status-update', (event, { isLoggedIn }) => {
    // Optional: Handle status updates from renderer if needed
});

ipcMain.on('set-service-visibility', (event, isVisible) => {
    console.log(`Setting service visibility to: ${isVisible}, chatMode: ${chatMode}`);
    
    if (chatMode === 'single') {
        // Single AI Mode: Handle singleModeViews
        Object.keys(singleModeViews).forEach(instanceKey => {
            if (singleModeViews[instanceKey] && singleModeViews[instanceKey].enabled && singleModeViews[instanceKey].view) {
                if (isVisible) {
                    try {
                        mainWindow.addBrowserView(singleModeViews[instanceKey].view);
                    } catch (e) {
                        console.error(`Failed to show single view for ${instanceKey}:`, e);
                    }
                } else {
                    try {
                        mainWindow.removeBrowserView(singleModeViews[instanceKey].view);
                    } catch (e) {
                        console.error(`Failed to hide single view for ${instanceKey}:`, e);
                    }
                }
            }
        });
    } else {
        // Multi AI Mode: Handle views
        Object.keys(views).forEach(service => {
            if (views[service] && views[service].enabled && views[service].view) {
                if (isVisible) {
                    try {
                        mainWindow.addBrowserView(views[service].view);
                    } catch (e) {
                        console.error(`Failed to show view for ${service}:`, e);
                    }
                } else {
                    try {
                        mainWindow.removeBrowserView(views[service].view);
                    } catch (e) {
                        console.error(`Failed to hide view for ${service}:`, e);
                    }
                }
            }
        });
    }
});

app.whenReady().then(() => {
    // Load saved session state (SESS-003)
    const savedState = store.get('sessionState', defaultSessionState);
    currentLayout = savedState.layout || '1x4';
    savedSessionUrls = savedState.serviceUrls || {}; // Load saved URLs for createServiceView
    isAnonymousMode = savedState.isAnonymousMode || false;
    
    // Restore Chat Mode state
    chatMode = savedState.chatMode || 'multi';
    if (chatMode === 'single' && savedState.singleAiConfig) {
        singleAiService = savedState.singleAiConfig.service;
        // Ensure max 3 instances (migration from older 4-instance sessions)
        const restored = savedState.singleAiConfig.activeInstances || [true, true, true];
        singleAiActiveInstances = restored.slice(0, SINGLE_MODE_MAX_INSTANCES);
        
        // Pre-populate lastKnownInstanceUrls with saved URLs to enable URL protection
        if (savedState.singleAiConfig.urls) {
            for (const [instanceKey, url] of Object.entries(savedState.singleAiConfig.urls)) {
                lastKnownInstanceUrls[instanceKey] = url;
                console.log(`[Session] Pre-populated lastKnownInstanceUrls[${instanceKey}] = ${url}`);
            }
        }
    }
    
    console.log('[Session] Loaded saved state:', savedState);
    console.log('[Session] Chat mode:', chatMode, 'singleAiService:', singleAiService);

    createWindow();

    // Send saved state to renderer after window is ready
    mainWindow.webContents.once('did-finish-load', () => {
        mainWindow.webContents.send('apply-saved-state', savedState);
    });

    // Initialize auto-updater (only in production/packaged mode)
    if (app.isPackaged) {
        initAutoUpdater(mainWindow);
        
        // Check for updates 3 seconds after app starts
        setTimeout(() => {
            console.log('[Updater] Starting initial update check...');
            checkForUpdates();
        }, 3000);
    } else {
        console.log('[Updater] Skipping update check in development mode');
    }
});

// Save session state function (reusable for close and quit events)
function saveSessionState() {
    const sessionState = {
        serviceUrls: {},
        layout: currentLayout,
        activeServices: [],
        isAnonymousMode: isAnonymousMode,
        isScrollSyncEnabled: isScrollSyncEnabled,
        // Chat Mode state
        chatMode: chatMode,
        singleAiConfig: null,
        multiAiConfig: null
    };

    if (chatMode === 'single' && singleAiService) {
        // Single AI Mode: Save instance URLs (limited to SINGLE_MODE_MAX_INSTANCES)
        const instanceUrls = {};
        Object.entries(singleModeViews).forEach(([instanceKey, viewObj]) => {
            if (viewObj && viewObj.view && !viewObj.view.webContents.isDestroyed()) {
                // Only save instances within the limit
                const idx = parseInt(instanceKey.split('-').pop(), 10);
                if (idx < SINGLE_MODE_MAX_INSTANCES) {
                    instanceUrls[instanceKey] = viewObj.view.webContents.getURL();
                }
            }
        });
        
        sessionState.singleAiConfig = {
            service: singleAiService,
            // Ensure only SINGLE_MODE_MAX_INSTANCES are saved
            activeInstances: singleAiActiveInstances.slice(0, SINGLE_MODE_MAX_INSTANCES),
            urls: instanceUrls
        };
        console.log('[Session] Single AI Mode config:', sessionState.singleAiConfig);
    } else {
        // Multi AI Mode: Collect URLs from all BrowserViews (SESS-002)
        services.forEach(service => {
            if (views[service] && views[service].view && !views[service].view.webContents.isDestroyed()) {
                sessionState.serviceUrls[service] = views[service].view.webContents.getURL();
                if (views[service].enabled) {
                    sessionState.activeServices.push(service);
                }
            }
        });

        // Enforce max 4 active services for persisted state
        if (sessionState.activeServices.length > 4) {
            sessionState.activeServices = services.filter(s => sessionState.activeServices.includes(s)).slice(0, 4);
        }
        
        sessionState.multiAiConfig = {
            activeServices: [...sessionState.activeServices],
            urls: { ...sessionState.serviceUrls }
        };
    }

    store.set('sessionState', sessionState);
    console.log('[Session] Saved state:', sessionState);
}

// Save session state before quit (SESS-001)
app.on('before-quit', () => {
    saveSessionState();
});

// IPC handler for renderer to report UI state (SESS-002)
ipcMain.on('report-ui-state', (event, uiState) => {
    // Update tracking variables for before-quit
    isAnonymousMode = uiState.isAnonymousMode || false;

    // Update the session state with UI control states
    const savedState = store.get('sessionState', defaultSessionState);
    const cappedActive = Array.isArray(uiState.activeServices) ? uiState.activeServices.slice(0, 4) : uiState.activeServices;
    store.set('sessionState', {
        ...savedState,
        isAnonymousMode: uiState.isAnonymousMode,
        isScrollSyncEnabled: uiState.isScrollSyncEnabled,
        layout: uiState.layout,
        activeServices: cappedActive
    });
});

// IPC handler to get current saved state (SESS-003)
ipcMain.handle('get-saved-session', () => {
    return store.get('sessionState', defaultSessionState);
});

// Renderer calls this when it finished saving IndexedDB history during app close.
ipcMain.handle('app-close-ready', async () => {
    ipcMain.emit('__app-close-ready__');
    return { ok: true };
});

app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});
